diff -purN a/src/build-scripts/install_homebrew_deps.bash b/src/build-scripts/install_homebrew_deps.bash
--- a/src/build-scripts/install_homebrew_deps.bash	2016-06-27 22:34:50.000000000 +0100
+++ b/src/build-scripts/install_homebrew_deps.bash	2016-06-27 22:37:25.000000000 +0100
@@ -25,7 +25,7 @@ brew install ilmbase openexr
 brew install boost-python
 brew install opencolorio partio
 brew install freetype libraw libpng webp
-brew install llvm34
+brew install llvm38
 #brew install homebrew/science/hdf5 --with-threadsafe
 #brew install field3d webp ffmpeg openjpeg opencv
 echo ""
diff -purN a/src/include/OSL/llvm_util.h b/src/include/OSL/llvm_util.h
--- a/src/include/OSL/llvm_util.h	2016-06-27 22:34:50.000000000 +0100
+++ b/src/include/OSL/llvm_util.h	2016-06-27 22:37:25.000000000 +0100
@@ -29,22 +29,32 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 #pragma once
 
 #include "export.h"
-#include "oslversion.h"
+#include "oslconfig.h"
 
+#include <memory>
 #include <vector>
 
+#ifndef OSL_LLVM_VERSION
+#  include <llvm/Config/config.h>
+#  define OSL_LLVM_VERSION (LLVM_VERSION_MAJOR*10+LLVM_VERSION_MINOR)
+#endif
+
+#if OSL_LLVM_VERSION < 36
+#  include "llvm_util_old.h"
+#else
+
+
 #ifdef LLVM_NAMESPACE
 namespace llvm = LLVM_NAMESPACE;
 #endif
 
 namespace llvm {
+  // Opaque type definitions
   class BasicBlock;
   class ConstantFolder;
   class ExecutionEngine;
   class Function;
   class FunctionType;
-  class JITMemoryManager;
-  class Linker;
   class LLVMContext;
   class Module;
   class PointerType;
@@ -52,22 +62,12 @@ namespace llvm {
   class Value;
   template<bool preserveNames, typename T, typename Inserter> class IRBuilder;
   template<bool preserveNames> class IRBuilderDefaultInserter;
-  namespace legacy {
-    class FunctionPassManager;
-    class PassManager;
-  }
 }
 
 
 
 OSL_NAMESPACE_ENTER
 
-namespace pvt {   // OSL::pvt
-
-
-class OSL_Dummy_JITMemoryManager;
-
-
 
 /// Wrapper class around LLVM functionality.  This handles all the
 /// gory details of actually dealing with LLVM.  It should be sufficiently
@@ -83,92 +83,74 @@ public:
                             llvm::IRBuilderDefaultInserter<true> > IRBuilder;
 
     /// Set debug level
-    void debug (int d) { m_debug = d; }
-    int debug () const { return m_debug; }
+    void debug (int d);
+    int debug () const;
+
+    /// Set whether or not we are using ORC JIT (default: MCJIT)
+    void orc_jit (bool enable);
+    bool orc_jit () const;
 
     /// Return a reference to the current context.
-    llvm::LLVMContext &context () const { return *m_llvm_context; }
+    llvm::LLVMContext &context () const;
 
     /// Return a pointer to the current module.  Make a new one if
     /// necessary.
-    llvm::Module *module () {
-        if (! m_llvm_module)
-            m_llvm_module = new_module();
-        return m_llvm_module;
-    }
-
-    /// Set the current module to m.
-    void module (llvm::Module *m) { m_llvm_module = m; }
+    llvm::Module *module ();
 
-    /// Create a new empty module.
-    llvm::Module *new_module (const char *id = "default");
+    /// Create a new empty module, make it the current module.
+    llvm::Module *new_module (string_view id = "default");
 
     /// Create a new module, populated with functions from the buffer
-    /// bitcode[0..size-1].  The name identifies the buffer.  If err is not
-    /// NULL, error messages will be stored there.
-    llvm::Module *module_from_bitcode (const char *bitcode, size_t size,
-                                       const std::string &name=std::string(),
+    /// bitcode[0..size-1], make it the current module.  The name identifies
+    /// the buffer.  If err is not NULL, error messages will be stored
+    /// there.
+    llvm::Module *module_from_bitcode (string_view bitcode,
+                                       string_view name = "",
                                        std::string *err=NULL);
 
+    enum HasVarArgs { NoVarArgs=0, VarArgs=1 };
+
     /// Create a new function (that will later be populated with
-    /// instructions) with up to 4 args.
-    llvm::Function *make_function (const std::string &name, bool fastcall,
+    /// instructions). If varargs is VarArgs, it will be marked as having
+    /// var args (default: no). If stub is StubOnly, the function will be a
+    /// stub only, but if it is FunctionWithCode (the default), the new
+    /// function will be the "current function" with a new basic block and
+    /// the insertion point set (so any subsequent ops will start filling in
+    /// the function's code. If no module has yet been created, a
+    /// new_module() will be created to house the function.
+    llvm::Function *make_function (string_view, bool fastcall,
+                                   llvm::Type *rettype,
+                                   array_view<llvm::Type*> paramtypes,
+                                   HasVarArgs varargs=NoVarArgs);
+    /// make_function with individually-passed parameter types (for up to 5
+    /// parameters).
+    llvm::Function *make_function (string_view, bool fastcall,
                                    llvm::Type *rettype,
                                    llvm::Type *arg1=NULL,
                                    llvm::Type *arg2=NULL,
                                    llvm::Type *arg3=NULL,
                                    llvm::Type *arg4=NULL);
 
-    /// Create a new function (that will later be populated with
-    /// instructions) with a vector of args.
-    llvm::Function *make_function (const std::string &name, bool fastcall,
-                                   llvm::Type *rettype,
-                                   const std::vector<llvm::Type*> &paramtypes,
-                                   bool varargs=false);
+    /// Create the declaration for a function that will be resolved
+    /// externally. It does not change the "current" function or the
+    /// IR insertion point.
+    llvm::Function *declare_extern_function (string_view, llvm::Type *rettype,
+                                             array_view<llvm::Type*> paramtypes,
+                                             HasVarArgs varargs=NoVarArgs);
 
     /// Set up a new current function that subsequent basic blocks will
     /// be added to.
-    void current_function (llvm::Function *func) { m_current_function = func; }
+    void current_function (llvm::Function *func);
 
     /// Return a ptr to the current function we're generating.
-    llvm::Function *current_function () const { return m_current_function; }
+    llvm::Function *current_function () const;
 
     /// Return the value ptr for the a-th argument of the current function.
     llvm::Value *current_function_arg (int a);
 
-
-    /// Create a new IR builder with the given block as entry point. If
-    /// block is NULL, a new basic block for the current function will be
-    /// created.
-    void new_builder (llvm::BasicBlock *block=NULL);
-
-    /// End the current builder
-    void end_builder ();
-
     /// Return the current IR builder, create a new one (for the current
     /// function) if necessary.
-    IRBuilder &builder () {
-        if (! m_builder)
-            new_builder ();
-        return *m_builder;
-    }
-
-    /// Create a new JITing ExecutionEngine and make it the current one.
-    /// Return a pointer to the new engine.  If err is not NULL, put any
-    /// errors there.
-    llvm::ExecutionEngine *make_jit_execengine (std::string *err=NULL);
-
-    /// Return a pointer to the current ExecutionEngine.  Create a JITing
-    /// ExecutionEngine if one isn't already set up.
-    llvm::ExecutionEngine *execengine () {
-        if (! m_llvm_exec)
-            make_jit_execengine();
-        return m_llvm_exec;
-    }
-
-    /// Replace the ExecutionEngine (pass NULL to simply delete the
-    /// current one).
-    void execengine (llvm::ExecutionEngine *exec);
+    IRBuilder &builder ();
 
     /// Change symbols in the module that are marked as having external
     /// linkage to an alternate linkage that allows them to be discarded if
@@ -185,18 +167,26 @@ public:
     /// Run the optimization passes.
     void do_optimize ();
 
+    /// Call when we've finished adding functions to the module and are
+    /// ready to optimize and codegen it.
+    void module_done ();
+
     /// Retrieve a callable pointer to the JITed version of a function.
     /// This will JIT the function if it hasn't already done so. Be sure
     /// you have already called do_optimize() if you want optimization.
-    void *getPointerToFunction (llvm::Function *func);
+    void *get_compiled_function (string_view name);
+    // void *get_compiled_function (llvm::Function *func);
+
+    typedef void* (*FunctionResolver)(const std::string &);
 
     /// Wrap ExecutionEngine::InstallLazyFunctionCreator.
     void InstallLazyFunctionCreator (void* (*P)(const std::string &));
 
 
     /// Create a new LLVM basic block (for the current function) and return
-    /// its handle.
-    llvm::BasicBlock *new_basic_block (const std::string &name=std::string());
+    /// its handle. If insert is true, set the insertion point for new
+    /// IR ops to be the new BB.
+    llvm::BasicBlock *new_basic_block (string_view name="", bool insert=false);
 
     /// Save the return block pointer when entering a function. If
     /// after==NULL, generate a new basic block for where to go after the
@@ -225,24 +215,24 @@ public:
     llvm::BasicBlock *loop_after_block () const;
 
 
-    llvm::Type *type_float() const { return m_llvm_type_float; }
-    llvm::Type *type_int() const { return m_llvm_type_int; }
-    llvm::Type *type_addrint() const { return m_llvm_type_addrint; }
-    llvm::Type *type_bool() const { return m_llvm_type_bool; }
-    llvm::Type *type_char() const { return m_llvm_type_char; }
-    llvm::Type *type_longlong() const { return m_llvm_type_longlong; }
-    llvm::Type *type_void() const { return m_llvm_type_void; }
-    llvm::Type *type_triple() const { return m_llvm_type_triple; }
-    llvm::Type *type_matrix() const { return m_llvm_type_matrix; }
-    llvm::Type *type_typedesc() const { return m_llvm_type_longlong; }
-    llvm::PointerType *type_void_ptr() const { return m_llvm_type_void_ptr; }
-    llvm::PointerType *type_string() { return m_llvm_type_char_ptr; }
-    llvm::PointerType *type_ustring_ptr() const { return m_llvm_type_ustring_ptr; }
-    llvm::PointerType *type_char_ptr() const { return m_llvm_type_char_ptr; }
-    llvm::PointerType *type_int_ptr() const { return m_llvm_type_int_ptr; }
-    llvm::PointerType *type_float_ptr() const { return m_llvm_type_float_ptr; }
-    llvm::PointerType *type_triple_ptr() const { return m_llvm_type_triple_ptr; }
-    llvm::PointerType *type_matrix_ptr() const { return m_llvm_type_matrix_ptr; }
+    llvm::Type *type_float() const;
+    llvm::Type *type_int() const;
+    llvm::Type *type_addrint() const;
+    llvm::Type *type_bool() const;
+    llvm::Type *type_char() const;
+    llvm::Type *type_longlong() const;
+    llvm::Type *type_void() const;
+    llvm::Type *type_triple() const;
+    llvm::Type *type_matrix() const;
+    llvm::Type *type_typedesc() const;
+    llvm::PointerType *type_void_ptr() const;
+    llvm::PointerType *type_string() const;
+    llvm::PointerType *type_ustring_ptr() const;
+    llvm::PointerType *type_char_ptr() const;
+    llvm::PointerType *type_int_ptr() const;
+    llvm::PointerType *type_float_ptr() const;
+    llvm::PointerType *type_triple_ptr() const;
+    llvm::PointerType *type_matrix_ptr() const;
 
     /// Generate the appropriate llvm type definition for a TypeDesc
     /// (this is the actual type, for example when we allocate it).
@@ -255,7 +245,7 @@ public:
     /// This will return a llvm::Type that is the same as a C struct
     /// comprised fields of the given types[], in order.
     llvm::Type *type_struct (const std::vector<llvm::Type *> &types,
-                             const std::string &name="");
+                             string_view name="");
 
     /// Return the llvm::Type that is a pointer to the given llvm type.
     llvm::Type *type_ptr (llvm::Type *type);
@@ -268,14 +258,14 @@ public:
     /// given return types, parameter types (in a vector), and whether it
     /// uses varargs conventions.
     llvm::FunctionType *type_function (llvm::Type *rettype,
-                                       const std::vector<llvm::Type*> &params,
-                                       bool varargs=false);
+                                       array_view<llvm::Type*> params,
+                                       HasVarArgs varargs=NoVarArgs);
 
     /// Return a llvm::PointerType that's a pointer to the described
     /// kind of function.
     llvm::PointerType *type_function_ptr (llvm::Type *rettype,
-                                          const std::vector<llvm::Type*> &params,
-                                          bool varargs=false);
+                                          array_view<llvm::Type*> params,
+                                          HasVarArgs varargs=NoVarArgs);
 
     /// Return the human-readable name of the type of the llvm type.
     std::string llvm_typename (llvm::Type *type) const;
@@ -305,10 +295,7 @@ public:
 
     /// Return an llvm::Value holding the given string constant.
     llvm::Value *constant (OIIO::ustring s);
-    llvm::Value *constant (const char *s) {
-        return constant(OIIO::ustring(s));
-    }
-    llvm::Value *constant (const std::string &s) {
+    llvm::Value *constant (string_view s) {
         return constant(OIIO::ustring(s));
     }
 
@@ -346,50 +333,47 @@ public:
     /// Generate an alloca instruction to allocate space for n copies of the
     /// given llvm type, and return its pointer.
     llvm::Value *op_alloca (llvm::Type *llvmtype, int n=1,
-                            const std::string &name=std::string());
+                            string_view name="");
     llvm::Value *op_alloca (llvm::PointerType *llvmtype, int n=1,
-                            const std::string &name=std::string()) {
+                            string_view name="") {
         return op_alloca ((llvm::Type *)llvmtype, n, name);
     }
 
     /// Generate an alloca instruction to allocate space for n copies of the
     /// given type, and return its pointer.
     llvm::Value *op_alloca (const OIIO::TypeDesc &type, int n=1,
-                            const std::string &name=std::string());
+                            string_view name="");
 
     /// Generate code for a call to the function pointer, with the given
     /// arg list.  Return an llvm::Value* corresponding to the return
     /// value of the function, if any.
     llvm::Value *call_function (llvm::Value *func,
-                                llvm::Value **args, int nargs);
+                                OIIO::array_view<llvm::Value *> args);
     /// Generate code for a call to the named function with the given arg
     /// list.  Return an llvm::Value* corresponding to the return value of
     /// the function, if any.
-    llvm::Value *call_function (const char *name,
-                                llvm::Value **args, int nargs);
-    template<size_t N>
-    llvm::Value* call_function (const char *name, llvm::Value* (&args)[N]) {
-        return call_function (name, &args[0], int(N));
-    }
+    llvm::Value *call_function (string_view name,
+                                OIIO::array_view<llvm::Value *> args);
 
-    llvm::Value *call_function (const char *name, llvm::Value *arg0) {
-        return call_function (name, &arg0, 1);
+    llvm::Value *call_function (string_view name, llvm::Value *arg0) {
+        llvm::Value *args[1] = { arg0 };
+        return call_function (name, args);
     }
-    llvm::Value *call_function (const char *name, llvm::Value *arg0,
+    llvm::Value *call_function (string_view name, llvm::Value *arg0,
                                 llvm::Value *arg1) {
         llvm::Value *args[2] = { arg0, arg1 };
-        return call_function (name, args, 2);
+        return call_function (name, args);
     }
-    llvm::Value *call_function (const char *name, llvm::Value *arg0,
+    llvm::Value *call_function (string_view name, llvm::Value *arg0,
                                 llvm::Value *arg1, llvm::Value *arg2) {
         llvm::Value *args[3] = { arg0, arg1, arg2 };
-        return call_function (name, args, 3);
+        return call_function (name, args);
     }
-    llvm::Value *call_function (const char *name, llvm::Value *arg0,
+    llvm::Value *call_function (string_view name, llvm::Value *arg0,
                                 llvm::Value *arg1, llvm::Value *arg2,
                                 llvm::Value *arg3) {
         llvm::Value *args[4] = { arg0, arg1, arg2, arg3 };
-        return call_function (name, args, 4);
+        return call_function (name, args);
     }
 
     /// Mark the function call (which MUST be the value returned by a
@@ -397,7 +381,8 @@ public:
     void mark_fast_func_call (llvm::Value *funccall);
 
     /// Set the code insertion point for subsequent ops to block.
-    void set_insert_point (llvm::BasicBlock *block);
+    /// If block is NULL, create a new basic block for the current function.
+    void set_insert_point (llvm::BasicBlock *block=NULL);
 
     /// Return op from a void function.  If retval is NULL, we are returning
     /// from a void function.
@@ -501,48 +486,14 @@ public:
     static size_t total_jit_memory_held ();
 
 private:
-    /// Return a pointer to the JIT memory manager.
-    llvm::JITMemoryManager *jitmm () const {
-        return (llvm::JITMemoryManager *)m_llvm_jitmm;
-    }
-
-    void SetupLLVM ();
-
-
-    int m_debug;
-    PerThreadInfo *m_thread;
-    llvm::LLVMContext *m_llvm_context;
-    llvm::Module *m_llvm_module;
-    IRBuilder *m_builder;
-    OSL_Dummy_JITMemoryManager *m_llvm_jitmm;
-    llvm::Function *m_current_function;
-    llvm::legacy::PassManager *m_llvm_module_passes;
-    llvm::legacy::FunctionPassManager *m_llvm_func_passes;
-    llvm::ExecutionEngine *m_llvm_exec;
-    std::vector<llvm::BasicBlock *> m_return_block;     // stack for func call
-    std::vector<llvm::BasicBlock *> m_loop_after_block; // stack for break
-    std::vector<llvm::BasicBlock *> m_loop_step_block;  // stack for continue
-
-    llvm::Type *m_llvm_type_float;
-    llvm::Type *m_llvm_type_int;
-    llvm::Type *m_llvm_type_addrint;
-    llvm::Type *m_llvm_type_bool;
-    llvm::Type *m_llvm_type_char;
-    llvm::Type *m_llvm_type_longlong;
-    llvm::Type *m_llvm_type_void;
-    llvm::Type *m_llvm_type_triple;
-    llvm::Type *m_llvm_type_matrix;
-    llvm::PointerType *m_llvm_type_void_ptr;
-    llvm::PointerType *m_llvm_type_ustring_ptr;
-    llvm::PointerType *m_llvm_type_char_ptr;
-    llvm::PointerType *m_llvm_type_int_ptr;
-    llvm::PointerType *m_llvm_type_float_ptr;
-    llvm::PointerType *m_llvm_type_triple_ptr;
-    llvm::PointerType *m_llvm_type_matrix_ptr;
-
+    class Impl;
+    std::unique_ptr<Impl> m_impl;
+    Impl *impl() { return m_impl.get(); }
 };
 
 
 
-}; // namespace pvt
 OSL_NAMESPACE_EXIT
+
+
+#endif
diff -purN a/src/include/OSL/llvm_util_old.h b/src/include/OSL/llvm_util_old.h
--- a/src/include/OSL/llvm_util_old.h	1970-01-01 01:00:00.000000000 +0100
+++ b/src/include/OSL/llvm_util_old.h	2016-06-27 22:37:25.000000000 +0100
@@ -0,0 +1,557 @@
+/*
+Copyright (c) 2009-2013 Sony Pictures Imageworks Inc., et al.
+All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+* Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+* Neither the name of Sony Pictures Imageworks nor the names of its
+  contributors may be used to endorse or promote products derived from
+  this software without specific prior written permission.
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#pragma once
+
+#include "export.h"
+#include "oslversion.h"
+
+#include <vector>
+
+#ifndef OSL_LLVM_VERSION
+#  include <llvm/Config/config.h>
+#  define OSL_LLVM_VERSION (LLVM_VERSION_MAJOR*10+LLVM_VERSION_MINOR)
+#endif
+#if OSL_LLVM_VERSION < 34 || OSL_LLVM_VERSION > 35
+#  error "llvm_util_old.h is only for OLD JIT, requires LLVM 3.4 or 3.5"
+#endif
+
+
+#ifdef LLVM_NAMESPACE
+namespace llvm = LLVM_NAMESPACE;
+#endif
+
+namespace llvm {
+  class BasicBlock;
+  class ConstantFolder;
+  class ExecutionEngine;
+  class Function;
+  class FunctionType;
+  class JITMemoryManager;
+  class Linker;
+  class LLVMContext;
+  class Module;
+  class PointerType;
+  class Type;
+  class Value;
+  template<bool preserveNames, typename T, typename Inserter> class IRBuilder;
+  template<bool preserveNames> class IRBuilderDefaultInserter;
+  namespace legacy {
+    class FunctionPassManager;
+    class PassManager;
+  }
+}
+
+
+
+OSL_NAMESPACE_ENTER
+
+namespace pvt {   // OSL::pvt
+
+
+class OSL_Dummy_JITMemoryManager;
+
+
+
+/// Wrapper class around LLVM functionality.  This handles all the
+/// gory details of actually dealing with LLVM.  It should be sufficiently
+/// generic that it would be useful for any LLVM-JITing app, and is not
+/// tied to OSL internals at all.
+class OSLEXECPUBLIC LLVM_Util {
+public:
+    LLVM_Util (int debuglevel=0);
+    ~LLVM_Util ();
+
+    struct PerThreadInfo;
+    typedef llvm::IRBuilder<true,llvm::ConstantFolder,
+                            llvm::IRBuilderDefaultInserter<true> > IRBuilder;
+
+    /// Set debug level
+    void debug (int d) { m_debug = d; }
+    int debug () const { return m_debug; }
+
+    /// Return a reference to the current context.
+    llvm::LLVMContext &context () const { return *m_llvm_context; }
+
+    /// Return a pointer to the current module.  Make a new one if
+    /// necessary.
+    llvm::Module *module () {
+        if (! m_llvm_module)
+            m_llvm_module = new_module();
+        return m_llvm_module;
+    }
+
+    /// Set the current module to m.
+    void module (llvm::Module *m) { m_llvm_module = m; }
+
+    /// Create a new empty module.
+    llvm::Module *new_module (const char *id = "default");
+
+    /// Create a new module, populated with functions from the buffer
+    /// bitcode[0..size-1].  The name identifies the buffer.  If err is not
+    /// NULL, error messages will be stored there.
+    llvm::Module *module_from_bitcode (const char *bitcode, size_t size,
+                                       const std::string &name=std::string(),
+                                       std::string *err=NULL);
+
+    /// Create a new function (that will later be populated with
+    /// instructions) with up to 4 args.
+    llvm::Function *make_function (const std::string &name, bool fastcall,
+                                   llvm::Type *rettype,
+                                   llvm::Type *arg1=NULL,
+                                   llvm::Type *arg2=NULL,
+                                   llvm::Type *arg3=NULL,
+                                   llvm::Type *arg4=NULL);
+
+    /// Create a new function (that will later be populated with
+    /// instructions) with a vector of args.
+    llvm::Function *make_function (const std::string &name, bool fastcall,
+                                   llvm::Type *rettype,
+                                   const std::vector<llvm::Type*> &paramtypes,
+                                   bool varargs=false);
+
+    /// Set up a new current function that subsequent basic blocks will
+    /// be added to.
+    void current_function (llvm::Function *func) { m_current_function = func; }
+
+    /// Return a ptr to the current function we're generating.
+    llvm::Function *current_function () const { return m_current_function; }
+
+    /// Return the value ptr for the a-th argument of the current function.
+    llvm::Value *current_function_arg (int a);
+
+
+    /// Create a new IR builder with the given block as entry point. If
+    /// block is NULL, a new basic block for the current function will be
+    /// created.
+    void new_builder (llvm::BasicBlock *block=NULL);
+
+    /// End the current builder
+    void end_builder ();
+
+    /// Return the current IR builder, create a new one (for the current
+    /// function) if necessary.
+    IRBuilder &builder () {
+        if (! m_builder)
+            new_builder ();
+        return *m_builder;
+    }
+
+    /// Create a new JITing ExecutionEngine and make it the current one.
+    /// Return a pointer to the new engine.  If err is not NULL, put any
+    /// errors there.
+    llvm::ExecutionEngine *make_jit_execengine (std::string *err=NULL);
+
+    /// Return a pointer to the current ExecutionEngine.  Create a JITing
+    /// ExecutionEngine if one isn't already set up.
+    llvm::ExecutionEngine *execengine () {
+        if (! m_llvm_exec)
+            make_jit_execengine();
+        return m_llvm_exec;
+    }
+
+    /// Replace the ExecutionEngine (pass NULL to simply delete the
+    /// current one).
+    void execengine (llvm::ExecutionEngine *exec);
+
+    /// Change symbols in the module that are marked as having external
+    /// linkage to an alternate linkage that allows them to be discarded if
+    /// not used within the module. Only do this for functions that start
+    /// with prefix, and that DON'T match anything in the two exceptions
+    /// lists.
+    void internalize_module_functions (const std::string &prefix,
+                                       const std::vector<std::string> &exceptions,
+                                       const std::vector<std::string> &moreexceptions);
+
+    /// Setup LLVM optimization passes.
+    void setup_optimization_passes (int optlevel);
+
+    /// Run the optimization passes.
+    void do_optimize ();
+
+    /// Retrieve a callable pointer to the JITed version of a function.
+    /// This will JIT the function if it hasn't already done so. Be sure
+    /// you have already called do_optimize() if you want optimization.
+    void *getPointerToFunction (llvm::Function *func);
+
+    /// Wrap ExecutionEngine::InstallLazyFunctionCreator.
+    void InstallLazyFunctionCreator (void* (*P)(const std::string &));
+
+
+    /// Create a new LLVM basic block (for the current function) and return
+    /// its handle.
+    llvm::BasicBlock *new_basic_block (const std::string &name=std::string());
+
+    /// Save the return block pointer when entering a function. If
+    /// after==NULL, generate a new basic block for where to go after the
+    /// function return.  Return the after BB.
+    llvm::BasicBlock *push_function (llvm::BasicBlock *after=NULL);
+
+    /// Pop basic return destination when exiting a function.  This includes
+    /// resetting the IR insertion point to the block following the
+    /// corresponding function call.
+    void pop_function ();
+
+    /// Return the basic block where we go after returning from the current
+    /// function.
+    llvm::BasicBlock *return_block () const;
+
+    /// Save the basic block pointers when entering a loop.
+    void push_loop (llvm::BasicBlock *step, llvm::BasicBlock *after);
+
+    /// Pop basic block pointers when exiting a loop.
+    void pop_loop ();
+
+    /// Return the basic block of the current loop's 'step' instructions.
+    llvm::BasicBlock *loop_step_block () const;
+
+    /// Return the basic block of the current loop's exit point.
+    llvm::BasicBlock *loop_after_block () const;
+
+
+    llvm::Type *type_float() const { return m_llvm_type_float; }
+    llvm::Type *type_int() const { return m_llvm_type_int; }
+    llvm::Type *type_addrint() const { return m_llvm_type_addrint; }
+    llvm::Type *type_bool() const { return m_llvm_type_bool; }
+    llvm::Type *type_char() const { return m_llvm_type_char; }
+    llvm::Type *type_longlong() const { return m_llvm_type_longlong; }
+    llvm::Type *type_void() const { return m_llvm_type_void; }
+    llvm::Type *type_triple() const { return m_llvm_type_triple; }
+    llvm::Type *type_matrix() const { return m_llvm_type_matrix; }
+    llvm::Type *type_typedesc() const { return m_llvm_type_longlong; }
+    llvm::PointerType *type_void_ptr() const { return m_llvm_type_void_ptr; }
+    llvm::PointerType *type_string() { return m_llvm_type_char_ptr; }
+    llvm::PointerType *type_ustring_ptr() const { return m_llvm_type_ustring_ptr; }
+    llvm::PointerType *type_char_ptr() const { return m_llvm_type_char_ptr; }
+    llvm::PointerType *type_int_ptr() const { return m_llvm_type_int_ptr; }
+    llvm::PointerType *type_float_ptr() const { return m_llvm_type_float_ptr; }
+    llvm::PointerType *type_triple_ptr() const { return m_llvm_type_triple_ptr; }
+    llvm::PointerType *type_matrix_ptr() const { return m_llvm_type_matrix_ptr; }
+
+    /// Generate the appropriate llvm type definition for a TypeDesc
+    /// (this is the actual type, for example when we allocate it).
+    llvm::Type *llvm_type (const OIIO::TypeDesc &typedesc);
+
+    /// This will return a llvm::Type that is the same as a C union of
+    /// the given types[].
+    llvm::Type *type_union (const std::vector<llvm::Type *> &types);
+
+    /// This will return a llvm::Type that is the same as a C struct
+    /// comprised fields of the given types[], in order.
+    llvm::Type *type_struct (const std::vector<llvm::Type *> &types,
+                             const std::string &name="");
+
+    /// Return the llvm::Type that is a pointer to the given llvm type.
+    llvm::Type *type_ptr (llvm::Type *type);
+
+    /// Return the llvm::Type that is an array of n elements of the given
+    /// llvm type.
+    llvm::Type *type_array (llvm::Type *type, int n);
+
+    /// Return an llvm::FunctionType that describes a function with the
+    /// given return types, parameter types (in a vector), and whether it
+    /// uses varargs conventions.
+    llvm::FunctionType *type_function (llvm::Type *rettype,
+                                       const std::vector<llvm::Type*> &params,
+                                       bool varargs=false);
+
+    /// Return a llvm::PointerType that's a pointer to the described
+    /// kind of function.
+    llvm::PointerType *type_function_ptr (llvm::Type *rettype,
+                                          const std::vector<llvm::Type*> &params,
+                                          bool varargs=false);
+
+    /// Return the human-readable name of the type of the llvm type.
+    std::string llvm_typename (llvm::Type *type) const;
+
+    /// Return the llvm::Type of the llvm value.
+    llvm::Type *llvm_typeof (llvm::Value *val) const;
+
+    /// Return the human-readable name of the type of the llvm value.
+    std::string llvm_typenameof (llvm::Value *val) const;
+
+    /// Return an llvm::Value holding the given floating point constant.
+    llvm::Value *constant (float f);
+
+    /// Return an llvm::Value holding the given integer constant.
+    llvm::Value *constant (int i);
+
+    /// Return an llvm::Value holding the given size_t constant.
+    llvm::Value *constant (size_t i);
+
+    /// Return an llvm::Value holding the given bool constant.
+    /// Change the name so it doesn't get mixed up with int.
+    llvm::Value *constant_bool (bool b);
+
+    /// Return a constant void pointer to the given constant address.
+    /// If the type specified is NULL, it will make a 'void *'.
+    llvm::Value *constant_ptr (void *p, llvm::PointerType *type=NULL);
+
+    /// Return an llvm::Value holding the given string constant.
+    llvm::Value *constant (OIIO::ustring s);
+    llvm::Value *constant (const char *s) {
+        return constant(OIIO::ustring(s));
+    }
+    llvm::Value *constant (const std::string &s) {
+        return constant(OIIO::ustring(s));
+    }
+
+    /// Return an llvm::Value for a long long that is a packed
+    /// representation of a TypeDesc.
+    llvm::Value *constant (const OIIO::TypeDesc &type);
+
+    /// Return an llvm::Value for a void* variable with value NULL.
+    llvm::Value *void_ptr_null ();
+
+    /// Cast the pointer variable specified by val to the kind of pointer
+    /// described by type (as an llvm pointer type).
+    llvm::Value *ptr_cast (llvm::Value* val, llvm::Type *type);
+    llvm::Value *ptr_cast (llvm::Value* val, llvm::PointerType *type) {
+        return ptr_cast (val, (llvm::Type *)type);
+    }
+
+    /// Cast the pointer variable specified by val to a pointer to the type
+    /// described by type (as an llvm data type).
+    llvm::Value *ptr_to_cast (llvm::Value* val, llvm::Type *type);
+
+    /// Cast the pointer variable specified by val to a pointer to the given
+    /// data type, return the llvm::Value of the new pointer.
+    llvm::Value *ptr_cast (llvm::Value* val, const OIIO::TypeDesc &type);
+
+    /// Cast the pointer variable specified by val to a pointer of type
+    /// void* return the llvm::Value of the new pointer.
+    llvm::Value *void_ptr (llvm::Value* val);
+
+    /// Generate a pointer that is (ptrtype)((char *)ptr + offset).
+    /// If ptrtype is NULL, just return a void*.
+    llvm::Value *offset_ptr (llvm::Value *ptr, int offset,
+                             llvm::Type *ptrtype=NULL);
+
+    /// Generate an alloca instruction to allocate space for n copies of the
+    /// given llvm type, and return its pointer.
+    llvm::Value *op_alloca (llvm::Type *llvmtype, int n=1,
+                            const std::string &name=std::string());
+    llvm::Value *op_alloca (llvm::PointerType *llvmtype, int n=1,
+                            const std::string &name=std::string()) {
+        return op_alloca ((llvm::Type *)llvmtype, n, name);
+    }
+
+    /// Generate an alloca instruction to allocate space for n copies of the
+    /// given type, and return its pointer.
+    llvm::Value *op_alloca (const OIIO::TypeDesc &type, int n=1,
+                            const std::string &name=std::string());
+
+    /// Generate code for a call to the function pointer, with the given
+    /// arg list.  Return an llvm::Value* corresponding to the return
+    /// value of the function, if any.
+    llvm::Value *call_function (llvm::Value *func,
+                                llvm::Value **args, int nargs);
+    /// Generate code for a call to the named function with the given arg
+    /// list.  Return an llvm::Value* corresponding to the return value of
+    /// the function, if any.
+    llvm::Value *call_function (const char *name,
+                                llvm::Value **args, int nargs);
+    template<size_t N>
+    llvm::Value* call_function (const char *name, llvm::Value* (&args)[N]) {
+        return call_function (name, &args[0], int(N));
+    }
+
+    llvm::Value *call_function (const char *name, llvm::Value *arg0) {
+        return call_function (name, &arg0, 1);
+    }
+    llvm::Value *call_function (const char *name, llvm::Value *arg0,
+                                llvm::Value *arg1) {
+        llvm::Value *args[2] = { arg0, arg1 };
+        return call_function (name, args, 2);
+    }
+    llvm::Value *call_function (const char *name, llvm::Value *arg0,
+                                llvm::Value *arg1, llvm::Value *arg2) {
+        llvm::Value *args[3] = { arg0, arg1, arg2 };
+        return call_function (name, args, 3);
+    }
+    llvm::Value *call_function (const char *name, llvm::Value *arg0,
+                                llvm::Value *arg1, llvm::Value *arg2,
+                                llvm::Value *arg3) {
+        llvm::Value *args[4] = { arg0, arg1, arg2, arg3 };
+        return call_function (name, args, 4);
+    }
+
+    /// Mark the function call (which MUST be the value returned by a
+    /// call_function()) as using the 'fast' calling convention.
+    void mark_fast_func_call (llvm::Value *funccall);
+
+    /// Set the code insertion point for subsequent ops to block.
+    void set_insert_point (llvm::BasicBlock *block);
+
+    /// Return op from a void function.  If retval is NULL, we are returning
+    /// from a void function.
+    void op_return (llvm::Value *retval=NULL);
+
+    /// Create a branch instruction to block and establish that as the as
+    /// the new code insertion point.
+    void op_branch (llvm::BasicBlock *block);
+
+    /// Create a conditional branch instruction to trueblock if cond is
+    /// true, to falseblock if cond is false, and establish trueblock as the
+    /// new insertion point).
+    void op_branch (llvm::Value *cond, llvm::BasicBlock *trueblock,
+                    llvm::BasicBlock *falseblock);
+
+    /// Generate code for a memset.
+    void op_memset (llvm::Value *ptr, int val, int len, int align=1);
+
+    /// Generate code for variable size memset
+    void op_memset (llvm::Value *ptr, int val, llvm::Value *len, int align=1);
+
+    /// Generate code for a memcpy.
+    void op_memcpy (llvm::Value *dst, llvm::Value *src, int len, int align=1);
+
+    /// Dereference a pointer:  return *ptr
+    llvm::Value *op_load (llvm::Value *ptr);
+
+    /// Store to a dereferenced pointer:   *ptr = val
+    void op_store (llvm::Value *val, llvm::Value *ptr);
+
+    // N.B. "GEP" -- GetElementPointer -- is a particular LLVM-ism that is
+    // the means for retrieving elements from some kind of aggregate: the
+    // i-th field in a struct, the i-th element of an array.  They can be
+    // chained together, to get at items in a recursive hierarchy.
+
+    /// Generate a GEP (get element pointer) where the element index is an
+    /// llvm::Value, which can be generated from either a constant or a
+    /// runtime-computed integer element index.
+    llvm::Value *GEP (llvm::Value *ptr, llvm::Value *elem);
+
+    /// Generate a GEP (get element pointer) with an integer element
+    /// offset.
+    llvm::Value *GEP (llvm::Value *ptr, int elem);
+
+    /// Generate a GEP (get element pointer) with two integer element
+    /// offsets.  This is just a special (and common) case of GEP where
+    /// we have a 2-level hierarchy and we have fixed element indices
+    /// that are known at compile time.
+    llvm::Value *GEP (llvm::Value *ptr, int elem1, int elem2);
+
+    // Arithmetic ops.  It auto-detects the type (int vs float).
+    // ...
+    llvm::Value *op_add (llvm::Value *a, llvm::Value *b);
+    llvm::Value *op_sub (llvm::Value *a, llvm::Value *b);
+    llvm::Value *op_neg (llvm::Value *a);
+    llvm::Value *op_mul (llvm::Value *a, llvm::Value *b);
+    llvm::Value *op_div (llvm::Value *a, llvm::Value *b);
+    llvm::Value *op_mod (llvm::Value *a, llvm::Value *b);
+    llvm::Value *op_float_to_int (llvm::Value *a);
+    llvm::Value *op_int_to_float (llvm::Value *a);
+    llvm::Value *op_bool_to_int (llvm::Value *a);
+    llvm::Value *op_float_to_double (llvm::Value *a);
+
+    llvm::Value *op_and (llvm::Value *a, llvm::Value *b);
+    llvm::Value *op_or (llvm::Value *a, llvm::Value *b);
+    llvm::Value *op_xor (llvm::Value *a, llvm::Value *b);
+    llvm::Value *op_shl (llvm::Value *a, llvm::Value *b);
+    llvm::Value *op_shr (llvm::Value *a, llvm::Value *b);
+    llvm::Value *op_not (llvm::Value *a);
+
+    /// Generate IR for (cond ? a : b).  Cond should be a bool.
+    llvm::Value *op_select (llvm::Value *cond, llvm::Value *a, llvm::Value *b);
+
+    // Comparison ops.  It auto-detects the type (int vs float).
+    // ordered only applies to float comparisons -- ordered means the
+    // comparison will succeed only if neither arg is NaN.
+    // ...
+    llvm::Value *op_eq (llvm::Value *a, llvm::Value *b, bool ordered=false);
+    llvm::Value *op_ne (llvm::Value *a, llvm::Value *b, bool ordered=false);
+    llvm::Value *op_gt (llvm::Value *a, llvm::Value *b, bool ordered=false);
+    llvm::Value *op_lt (llvm::Value *a, llvm::Value *b, bool ordered=false);
+    llvm::Value *op_ge (llvm::Value *a, llvm::Value *b, bool ordered=false);
+    llvm::Value *op_le (llvm::Value *a, llvm::Value *b, bool ordered=false);
+
+    /// Write the module's bitcode (after compilation/optimization) to a
+    /// file.  If err is not NULL, errors will be deposited there.
+    void write_bitcode_file (const char *filename, std::string *err=NULL);
+
+    /// Convert a function's bitcode to a string.
+    std::string bitcode_string (llvm::Function *func);
+
+    /// Delete the IR for the body of the given function to reclaim its
+    /// memory (only helpful if we know we won't use it again).
+    void delete_func_body (llvm::Function *func);
+
+    /// Is the function empty, except for simply a ret statement?
+    bool func_is_empty (llvm::Function *func);
+
+    std::string func_name (llvm::Function *f);
+
+    static size_t total_jit_memory_held ();
+
+private:
+    /// Return a pointer to the JIT memory manager.
+    llvm::JITMemoryManager *jitmm () const {
+        return (llvm::JITMemoryManager *)m_llvm_jitmm;
+    }
+
+    void SetupLLVM ();
+
+
+    int m_debug;
+    PerThreadInfo *m_thread;
+    llvm::LLVMContext *m_llvm_context;
+    llvm::Module *m_llvm_module;
+    IRBuilder *m_builder;
+    OSL_Dummy_JITMemoryManager *m_llvm_jitmm;
+    llvm::Function *m_current_function;
+    llvm::legacy::PassManager *m_llvm_module_passes;
+    llvm::legacy::FunctionPassManager *m_llvm_func_passes;
+    llvm::ExecutionEngine *m_llvm_exec;
+    std::vector<llvm::BasicBlock *> m_return_block;     // stack for func call
+    std::vector<llvm::BasicBlock *> m_loop_after_block; // stack for break
+    std::vector<llvm::BasicBlock *> m_loop_step_block;  // stack for continue
+
+    llvm::Type *m_llvm_type_float;
+    llvm::Type *m_llvm_type_int;
+    llvm::Type *m_llvm_type_addrint;
+    llvm::Type *m_llvm_type_bool;
+    llvm::Type *m_llvm_type_char;
+    llvm::Type *m_llvm_type_longlong;
+    llvm::Type *m_llvm_type_void;
+    llvm::Type *m_llvm_type_triple;
+    llvm::Type *m_llvm_type_matrix;
+    llvm::PointerType *m_llvm_type_void_ptr;
+    llvm::PointerType *m_llvm_type_ustring_ptr;
+    llvm::PointerType *m_llvm_type_char_ptr;
+    llvm::PointerType *m_llvm_type_int_ptr;
+    llvm::PointerType *m_llvm_type_float_ptr;
+    llvm::PointerType *m_llvm_type_triple_ptr;
+    llvm::PointerType *m_llvm_type_matrix_ptr;
+
+};
+
+
+
+}; // namespace pvt
+OSL_NAMESPACE_EXIT
diff -purN a/src/include/OSL/oslconfig.h b/src/include/OSL/oslconfig.h
--- a/src/include/OSL/oslconfig.h	2016-06-27 22:34:50.000000000 +0100
+++ b/src/include/OSL/oslconfig.h	2016-06-27 22:37:25.000000000 +0100
@@ -120,6 +120,7 @@ using OIIO::TypeDesc;
 using OIIO::ustring;
 using OIIO::ustringHash;
 using OIIO::string_view;
+using OIIO::array_view;
 
 // Sort out smart pointers
 #if OSL_CPLUSPLUS_VERSION >= 11
diff -purN a/src/liboslexec/backendllvm.cpp b/src/liboslexec/backendllvm.cpp
--- a/src/liboslexec/backendllvm.cpp	2016-06-27 22:34:50.000000000 +0100
+++ b/src/liboslexec/backendllvm.cpp	2016-06-27 22:37:25.000000000 +0100
@@ -85,13 +85,15 @@ check_cwd (ShadingSystemImpl &shadingsys
 
 
 BackendLLVM::BackendLLVM (ShadingSystemImpl &shadingsys,
-                          ShaderGroup &group, ShadingContext *ctx)
-    : OSOProcessorBase (shadingsys, group, ctx),
-      ll(llvm_debug()),
+                          ShaderGroup &group, ShadingContext *ctx,
+                          LLVM_Util &ll)
+    : OSOProcessorBase (shadingsys, group, ctx), ll(ll),
       m_stat_total_llvm_time(0), m_stat_llvm_setup_time(0),
       m_stat_llvm_irgen_time(0), m_stat_llvm_opt_time(0),
       m_stat_llvm_jit_time(0)
 {
+    ll.debug (llvm_debug());
+    ll.orc_jit (shadingsys.m_llvm_orcjit);
 #ifdef OSL_SPI
     // Temporary (I hope) check to diagnose an intermittent failure of
     // getcwd inside LLVM. Oy.
@@ -677,8 +679,8 @@ BackendLLVM::userdata_initialized_ref (i
 
 llvm::Value *
 BackendLLVM::llvm_call_function (const char *name, 
-                                      const Symbol **symargs, int nargs,
-                                      bool deriv_ptrs)
+                                 const Symbol **symargs, int nargs,
+                                 bool deriv_ptrs)
 {
     std::vector<llvm::Value *> valargs;
     valargs.resize ((size_t)nargs);
@@ -692,8 +694,7 @@ BackendLLVM::llvm_call_function (const c
         else
             valargs[i] = llvm_load_value (s);
     }
-    return ll.call_function (name, (valargs.size())? &valargs[0]: NULL,
-                             (int)valargs.size());
+    return ll.call_function (name, valargs);
 }
 
 
diff -purN a/src/liboslexec/backendllvm.h b/src/liboslexec/backendllvm.h
--- a/src/liboslexec/backendllvm.h	2016-06-27 22:34:50.000000000 +0100
+++ b/src/liboslexec/backendllvm.h	2016-06-27 22:37:25.000000000 +0100
@@ -51,7 +51,7 @@ namespace pvt {   // OSL::pvt
 class BackendLLVM : public OSOProcessorBase {
 public:
     BackendLLVM (ShadingSystemImpl &shadingsys, ShaderGroup &group,
-                ShadingContext *context);
+                ShadingContext *context, LLVM_Util &ll);
 
     virtual ~BackendLLVM ();
 
@@ -401,7 +401,12 @@ public:
             shadingsys().m_stat_tex_calls_as_handles += 1;
     }
 
-    LLVM_Util ll;
+    /// Return the unique/mangled function name of an instance.
+    std::string layer_function_name (ShaderInstance *inst) {
+        return Strutil::format ("%s_%d", inst->layername(), inst->id());
+    }
+
+    LLVM_Util &ll;
 
 private:
     std::vector<int> m_layer_remap;     ///< Remapping of layer ordering
diff -purN a/src/liboslexec/CMakeLists.txt b/src/liboslexec/CMakeLists.txt
--- a/src/liboslexec/CMakeLists.txt	2016-06-27 22:34:50.000000000 +0100
+++ b/src/liboslexec/CMakeLists.txt	2016-06-27 22:37:25.000000000 +0100
@@ -13,9 +13,16 @@ SET ( liboslexec_srcs
           opclosure.cpp
           shadeimage.cpp
           backendllvm.cpp
-          llvm_gen.cpp llvm_instance.cpp llvm_util.cpp
+          llvm_gen.cpp llvm_instance.cpp
+#          llvm_util.cpp llvm_util_old.cpp
     )
 
+if (${OSL_LLVM_VERSION} LESS 36)
+    list (APPEND liboslexec_srcs llvm_util_old)
+else ()
+    list (APPEND liboslexec_srcs llvm_util)
+endif ()
+
 # oslcomp symbols used in oslexec
 if (NOT BUILDSTATIC)
     LIST(APPEND liboslexec_srcs
@@ -157,6 +164,11 @@ if (OSL_BUILD_TESTS)
     target_link_libraries ( accum_test oslexec oslcomp ${Boost_LIBRARIES} ${CMAKE_DL_LIBS} ${EXTRA_OSLEXEC_LIBRARIES} )
     add_test (unit_accum "${CMAKE_BINARY_DIR}/src/liboslexec/accum_test")
 
+    add_executable (llvm_test llvm_test.cpp)
+    target_link_libraries ( llvm_test ${OPENIMAGEIO_LIBRARY} ${CMAKE_DL_LIBS} ${LLVM_LIBRARY} ${LLVM_MCJIT_LIBRARY}
+                            ${LLVM_LIBRARIES} ${LLVM_LDFLAGS} ${EXTRA_OSLEXEC_LIBRARIES} )
+    add_test (unit_llvm "${CMAKE_BINARY_DIR}/src/liboslexec/llvm_test")
+
     add_executable (llvmutil_test llvmutil_test.cpp)
     target_link_libraries ( llvmutil_test oslexec oslcomp ${Boost_LIBRARIES} ${CMAKE_DL_LIBS} ${EXTRA_OSLEXEC_LIBRARIES} )
     add_test (unit_llvmutil "${CMAKE_BINARY_DIR}/src/liboslexec/llvmutil_test")
diff -purN a/src/liboslexec/llvm_gen.cpp b/src/liboslexec/llvm_gen.cpp
--- a/src/liboslexec/llvm_gen.cpp	2016-06-27 22:34:50.000000000 +0100
+++ b/src/liboslexec/llvm_gen.cpp	2016-06-27 22:37:25.000000000 +0100
@@ -158,7 +158,7 @@ BackendLLVM::llvm_call_layer (int layer,
     std::string name = Strutil::format ("%s_%d", parent->layername().c_str(),
                                         parent->id());
     // Mark the call as a fast call
-    llvm::Value *funccall = ll.call_function (name.c_str(), args, 2);
+    llvm::Value *funccall = ll.call_function (name, args);
     if (!parent->entry_layer())
         ll.mark_fast_func_call (funccall);
 
@@ -378,8 +378,7 @@ LLVMGEN (llvm_gen_printf)
 
     // Construct the function name and call it.
     std::string opname = std::string("osl_") + op.opname().string();
-    llvm::Value *ret = rop.ll.call_function (opname.c_str(), &call_args[0],
-                                               (int)call_args.size());
+    llvm::Value *ret = rop.ll.call_function (opname, call_args);
 
     // The format op returns a string value, put in in the right spot
     if (op.opname() == op_format)
@@ -403,7 +402,7 @@ LLVMGEN (llvm_gen_add)
         valargs[0] = rop.sg_void_ptr();
         valargs[1] = rop.llvm_load_value (A);
         valargs[2] = rop.llvm_load_value (B);
-        llvm::Value *res = rop.ll.call_function ("osl_add_closure_closure", valargs, 3);
+        llvm::Value *res = rop.ll.call_function ("osl_add_closure_closure", valargs);
         rop.llvm_store_value (res, Result, 0, NULL, 0);
         return true;
     }
@@ -511,8 +510,8 @@ LLVMGEN (llvm_gen_mul)
             valargs[1] = rop.llvm_load_value (B);
             valargs[2] = tfloat ? rop.llvm_load_value (A) : rop.llvm_void_ptr(A);
         }
-        llvm::Value *res = tfloat ? rop.ll.call_function ("osl_mul_closure_float", valargs, 3)
-                                  : rop.ll.call_function ("osl_mul_closure_color", valargs, 3);
+        llvm::Value *res = tfloat ? rop.ll.call_function ("osl_mul_closure_float", valargs)
+                                  : rop.ll.call_function ("osl_mul_closure_color", valargs);
         rop.llvm_store_value (res, Result, 0, NULL, 0);
         return true;
     }
@@ -1326,7 +1325,7 @@ LLVMGEN (llvm_gen_construct_color)
         args[0] = rop.sg_void_ptr ();  // shader globals
         args[1] = rop.llvm_void_ptr (Result, 0);  // color
         args[2] = rop.llvm_load_value (Space); // from
-        rop.ll.call_function ("osl_prepend_color_from", args, 3);
+        rop.ll.call_function ("osl_prepend_color_from", args);
         // FIXME(deriv): Punt on derivs for color ctrs with space names.
         // We should try to do this right, but we never had it right for
         // the interpreter, to it's probably not an emergency.
@@ -1389,10 +1388,10 @@ LLVMGEN (llvm_gen_construct_triple)
             // Note that for the case of non-constant strings, passing empty
             // from & to will make transform_points just tell us if ANY 
             // nonlinear transformations potentially are supported.
-            rop.ll.call_function ("osl_transform_triple_nonlinear", args, 8);
+            rop.ll.call_function ("osl_transform_triple_nonlinear", args);
         } else {
             // definitely not a nonlinear transformation
-            rop.ll.call_function ("osl_transform_triple", args, 8);
+            rop.ll.call_function ("osl_transform_triple", args);
         }
     }
 
@@ -1423,7 +1422,7 @@ LLVMGEN (llvm_gen_matrix)
         args[1] = rop.llvm_void_ptr(Result);  // result
         args[2] = rop.llvm_load_value(*rop.opargsym (op, 1));  // from
         args[3] = rop.llvm_load_value(*rop.opargsym (op, 2));  // to
-        rop.ll.call_function ("osl_get_from_to_matrix", args, 4);
+        rop.ll.call_function ("osl_get_from_to_matrix", args);
     } else {
         if (nfloats == 1) {
             for (int i = 0; i < 16; i++) {
@@ -1445,7 +1444,7 @@ LLVMGEN (llvm_gen_matrix)
             args[0] = rop.sg_void_ptr();  // shader globals
             args[1] = rop.llvm_void_ptr(Result);  // result
             args[2] = rop.llvm_load_value(*rop.opargsym (op, 1));  // from
-            rop.ll.call_function ("osl_prepend_matrix_from", args, 3);
+            rop.ll.call_function ("osl_prepend_matrix_from", args);
         }
     }
     if (Result.has_derivs())
@@ -1471,7 +1470,7 @@ LLVMGEN (llvm_gen_getmatrix)
     args[1] = rop.llvm_void_ptr(M);  // matrix result
     args[2] = rop.llvm_load_value(From);
     args[3] = rop.llvm_load_value(To);
-    llvm::Value *result = rop.ll.call_function ("osl_get_from_to_matrix", args, 4);
+    llvm::Value *result = rop.ll.call_function ("osl_get_from_to_matrix", args);
     rop.llvm_store_value (result, Result);
     rop.llvm_zero_derivs (M);
     return true;
@@ -1531,10 +1530,10 @@ LLVMGEN (llvm_gen_transform)
         // Note that for the case of non-constant strings, passing empty
         // from & to will make transform_points just tell us if ANY 
         // nonlinear transformations potentially are supported.
-        rop.ll.call_function ("osl_transform_triple_nonlinear", args, 8);
+        rop.ll.call_function ("osl_transform_triple_nonlinear", args);
     } else {
         // definitely not a nonlinear transformation
-        rop.ll.call_function ("osl_transform_triple", args, 8);
+        rop.ll.call_function ("osl_transform_triple", args);
     }
     return true;
 }
@@ -1739,8 +1738,7 @@ LLVMGEN (llvm_gen_regex)
     // Pass whether or not to do the full match
     call_args.push_back (rop.ll.constant(fullmatch));
 
-    llvm::Value *ret = rop.ll.call_function ("osl_regex_impl", &call_args[0],
-                                               (int)call_args.size());
+    llvm::Value *ret = rop.ll.call_function ("osl_regex_impl", call_args);
     rop.llvm_store_value (ret, Result);
     return true;
 }
@@ -1832,7 +1830,6 @@ LLVMGEN (llvm_gen_sincos)
     Symbol& Theta   = *rop.opargsym (op, 0);
     Symbol& Sin_out = *rop.opargsym (op, 1);
     Symbol& Cos_out = *rop.opargsym (op, 2);
-    std::vector<llvm::Value *> valargs;
     bool theta_deriv   = Theta.has_derivs();
     bool result_derivs = (Sin_out.has_derivs() || Cos_out.has_derivs());
 
@@ -1848,12 +1845,13 @@ LLVMGEN (llvm_gen_sincos)
         else ASSERT (0);
     }
     // push back llvm arguments
+    std::vector<llvm::Value *> valargs;
     valargs.push_back ( (theta_deriv && result_derivs) || Theta.typespec().is_triple() ? 
           rop.llvm_void_ptr (Theta) : rop.llvm_load_value (Theta));
     valargs.push_back (rop.llvm_void_ptr (Sin_out));
     valargs.push_back (rop.llvm_void_ptr (Cos_out));
 
-    rop.ll.call_function (name.c_str(), &valargs[0], 3);
+    rop.ll.call_function (name, valargs);
 
     // If the input angle didn't have derivatives, we would not have
     // called the version of sincos with derivs; however in that case we
@@ -2258,7 +2256,7 @@ LLVMGEN (llvm_gen_texture)
     args.push_back (rop.ll.void_ptr (alpha    ? alpha    : rop.ll.void_ptr_null()));
     args.push_back (rop.ll.void_ptr (dalphadx ? dalphadx : rop.ll.void_ptr_null()));
     args.push_back (rop.ll.void_ptr (dalphady ? dalphady : rop.ll.void_ptr_null()));
-    rop.ll.call_function ("osl_texture", &args[0], (int)args.size());
+    rop.ll.call_function ("osl_texture", args);
     rop.generated_texture_call (texture_handle != NULL);
     return true;
 }
@@ -2333,7 +2331,7 @@ LLVMGEN (llvm_gen_texture3d)
     args.push_back (rop.ll.void_ptr (dalphadx ? dalphadx : rop.ll.void_ptr_null()));
     args.push_back (rop.ll.void_ptr (dalphady ? dalphady : rop.ll.void_ptr_null()));
     args.push_back (rop.ll.void_ptr_null());  // No dalphadz for now
-    rop.ll.call_function ("osl_texture3d", &args[0], (int)args.size());
+    rop.ll.call_function ("osl_texture3d", args);
     rop.generated_texture_call (texture_handle != NULL);
     return true;
 }
@@ -2399,7 +2397,7 @@ LLVMGEN (llvm_gen_environment)
         args.push_back (rop.ll.void_ptr_null());
         args.push_back (rop.ll.void_ptr_null());
     }
-    rop.ll.call_function ("osl_environment", &args[0], (int)args.size());
+    rop.ll.call_function ("osl_environment", args);
     rop.generated_texture_call (texture_handle != NULL);
     return true;
 }
@@ -2469,8 +2467,7 @@ LLVMGEN (llvm_gen_trace)
     args.push_back (rop.llvm_void_ptr (Dir, 0));
     args.push_back (rop.llvm_void_ptr (Dir, 1));
     args.push_back (rop.llvm_void_ptr (Dir, 2));
-    llvm::Value *r = rop.ll.call_function ("osl_trace", &args[0],
-                                             (int)args.size());
+    llvm::Value *r = rop.ll.call_function ("osl_trace", args);
     rop.llvm_store_value (r, Result);
     return true;
 }
@@ -2709,8 +2706,7 @@ LLVMGEN (llvm_gen_noise)
         llvm::outs() << "    " << *args[i] << "\n";
 #endif
 
-    llvm::Value *r = rop.ll.call_function (funcname.c_str(),
-                                             &args[0], (int)args.size());
+    llvm::Value *r = rop.ll.call_function (funcname, args);
     if (outdim == 1 && !derivs) {
         // Just plain float (no derivs) returns its value
         rop.llvm_store_value (r, Result);
@@ -2785,7 +2781,7 @@ LLVMGEN (llvm_gen_getattribute)
     args.push_back (rop.ll.constant_ptr ((void *) dest_type));
     args.push_back (rop.llvm_void_ptr (Destination));
 
-    llvm::Value *r = rop.ll.call_function ("osl_get_attribute", &args[0], args.size());
+    llvm::Value *r = rop.ll.call_function ("osl_get_attribute", args);
     rop.llvm_store_value (r, Result);
 
     return true;
@@ -2831,8 +2827,7 @@ LLVMGEN (llvm_gen_gettextureinfo)
     // destination
     args.push_back (rop.llvm_void_ptr (Data));
 
-    llvm::Value *r = rop.ll.call_function ("osl_get_textureinfo",
-                                           &args[0], args.size());
+    llvm::Value *r = rop.ll.call_function ("osl_get_textureinfo", args);
     rop.llvm_store_value (r, Result);
     /* Do not leave derivs uninitialized */
     if (Data.has_derivs())
@@ -2883,7 +2878,7 @@ LLVMGEN (llvm_gen_getmessage)
     args[7] = rop.ll.constant(op.sourcefile());
     args[8] = rop.ll.constant(op.sourceline());
 
-    llvm::Value *r = rop.ll.call_function ("osl_getmessage", args, 9);
+    llvm::Value *r = rop.ll.call_function ("osl_getmessage", args);
     rop.llvm_store_value (r, Result);
     return true;
 }
@@ -2917,7 +2912,7 @@ LLVMGEN (llvm_gen_setmessage)
     args[5] = rop.ll.constant(op.sourcefile());
     args[6] = rop.ll.constant(op.sourceline());
 
-    rop.ll.call_function ("osl_setmessage", args, 7);
+    rop.ll.call_function ("osl_setmessage", args);
     return true;
 }
 
@@ -2960,7 +2955,7 @@ LLVMGEN (llvm_gen_calculatenormal)
     args.push_back (rop.llvm_void_ptr (Result));
     args.push_back (rop.sg_void_ptr());
     args.push_back (rop.llvm_void_ptr (P));
-    rop.ll.call_function ("osl_calculatenormal", &args[0], args.size());
+    rop.ll.call_function ("osl_calculatenormal", args);
     if (Result.has_derivs())
         rop.llvm_zero_derivs (Result);
     return true;
@@ -3049,7 +3044,7 @@ LLVMGEN (llvm_gen_spline)
     else
         args.push_back (rop.ll.constant ((int)Knots.typespec().arraylength()));
     args.push_back (rop.ll.constant ((int)Knots.typespec().arraylength()));
-    rop.ll.call_function (name.c_str(), &args[0], args.size());
+    rop.ll.call_function (name.c_str(), args);
 
     if (Result.has_derivs() && !result_derivs)
         rop.llvm_zero_derivs (Result);
@@ -3130,11 +3125,12 @@ LLVMGEN (llvm_gen_closure)
     llvm::Value *sg_ptr = rop.sg_void_ptr();
     llvm::Value *id_int = rop.ll.constant(clentry->id);
     llvm::Value *size_int = rop.ll.constant(clentry->struct_size);
-    llvm::Value *alloc_args[4] = { sg_ptr, id_int, size_int,
-                                   weighted ? rop.llvm_void_ptr(*weight) : NULL };
+    std::vector<llvm::Value *> alloc_args { sg_ptr, id_int, size_int };
+    if (weighted)
+        alloc_args.push_back (rop.llvm_void_ptr(*weight));
     llvm::Value *return_ptr = weighted ?
-          rop.ll.call_function ("osl_allocate_weighted_closure_component", alloc_args, 4)
-        : rop.ll.call_function ("osl_allocate_closure_component", alloc_args, 3);
+          rop.ll.call_function ("osl_allocate_weighted_closure_component", alloc_args)
+        : rop.ll.call_function ("osl_allocate_closure_component", alloc_args);
     llvm::Value *comp_void_ptr = return_ptr;
 
     // For the weighted closures, we need a surrounding "if" so that it's safe
@@ -3162,7 +3158,7 @@ LLVMGEN (llvm_gen_closure)
         // Call clentry->prepare(renderservices *, int id, void *mem)
         llvm::Value *funct_ptr = rop.ll.constant_ptr((void *)clentry->prepare, rop.llvm_type_prepare_closure_func());
         llvm::Value *args[3] = {render_ptr, id_int, mem_void_ptr};
-        rop.ll.call_function (funct_ptr, args, 3);
+        rop.ll.call_function (funct_ptr, args);
     } else {
         rop.ll.op_memset (mem_void_ptr, 0, clentry->struct_size, 4 /*align*/);
     }
@@ -3194,7 +3190,7 @@ LLVMGEN (llvm_gen_closure)
         // Call clentry->setup(renderservices *, int id, void *mem)
         llvm::Value *funct_ptr = rop.ll.constant_ptr((void *)clentry->setup, rop.llvm_type_setup_closure_func());
         llvm::Value *args[3] = {render_ptr, id_int, mem_void_ptr};
-        rop.ll.call_function (funct_ptr, args, 3);
+        rop.ll.call_function (funct_ptr, args);
     }
 
     llvm_gen_keyword_fill(rop, op, clentry, closure_name, mem_void_ptr,
@@ -3299,7 +3295,7 @@ LLVMGEN (llvm_gen_pointcloud_search)
     // N.B. the op_branch sets sizeok_block as the new insert point
 
     // non-error code case
-    llvm::Value *count = rop.ll.call_function ("osl_pointcloud_search", &args[0], args.size());
+    llvm::Value *count = rop.ll.call_function ("osl_pointcloud_search", args);
     // Clear derivs if necessary
     for (size_t i = 0; i < clear_derivs_of.size(); ++i)
         rop.llvm_zero_derivs (*clear_derivs_of[i], count);
@@ -3315,7 +3311,7 @@ LLVMGEN (llvm_gen_pointcloud_search)
     args.push_back (rop.ll.constant_ptr ((void *)errorfmt.c_str()));
     args.push_back (rop.ll.constant_ptr ((void *)op.sourcefile().c_str()));
     args.push_back (rop.ll.constant (op.sourceline()));
-    rop.ll.call_function ("osl_error", &args[0], args.size());
+    rop.ll.call_function ("osl_error", args);
 
     rop.ll.op_branch (after_block);
     return true;
@@ -3360,7 +3356,7 @@ LLVMGEN (llvm_gen_pointcloud_get)
     args.push_back (rop.llvm_load_value (Attr_name));
     args.push_back (rop.ll.constant (Data.typespec().simpletype()));
     args.push_back (rop.llvm_void_ptr (Data));
-    llvm::Value *found = rop.ll.call_function ("osl_pointcloud_get", &args[0], args.size());
+    llvm::Value *found = rop.ll.call_function ("osl_pointcloud_get", args);
     rop.llvm_store_value (found, Result);
     if (Data.has_derivs())
         rop.llvm_zero_derivs (Data, count);
@@ -3374,7 +3370,7 @@ LLVMGEN (llvm_gen_pointcloud_get)
     args.push_back (rop.ll.constant_ptr ((void *)errorfmt.c_str()));
     args.push_back (rop.ll.constant_ptr ((void *)op.sourcefile().c_str()));
     args.push_back (rop.ll.constant (op.sourceline()));
-    rop.ll.call_function ("osl_error", &args[0], args.size());
+    rop.ll.call_function ("osl_error", args);
 
     rop.ll.op_branch (after_block);
     return true;
@@ -3415,7 +3411,7 @@ LLVMGEN (llvm_gen_pointcloud_write)
             rop.ll.constant (valsym->typespec().simpletype()), // type[i]
             rop.llvm_void_ptr (*valsym)  // value[i]
         };
-        rop.ll.call_function ("osl_pointcloud_write_helper", &args[0], 7);
+        rop.ll.call_function ("osl_pointcloud_write_helper", args);
     }
 
     llvm::Value * args[7] = {
@@ -3427,7 +3423,7 @@ LLVMGEN (llvm_gen_pointcloud_write)
         rop.ll.void_ptr (types),   // attribute types array
         rop.ll.void_ptr (values)   // attribute values array
     };
-    llvm::Value *ret = rop.ll.call_function ("osl_pointcloud_write", &args[0], 7);
+    llvm::Value *ret = rop.ll.call_function ("osl_pointcloud_write", args);
     rop.llvm_store_value (ret, Result);
 
     return true;
@@ -3454,7 +3450,7 @@ LLVMGEN (llvm_gen_dict_find)
     args[1] = rop.llvm_load_value(Source);
     args[2] = rop.llvm_load_value (Query);
     const char *func = sourceint ? "osl_dict_find_iis" : "osl_dict_find_iss";
-    llvm::Value *ret = rop.ll.call_function (func, &args[0], 3);
+    llvm::Value *ret = rop.ll.call_function (func, args);
     rop.llvm_store_value (ret, Result);
     return true;
 }
@@ -3470,8 +3466,8 @@ LLVMGEN (llvm_gen_dict_next)
     Symbol& NodeID = *rop.opargsym (op, 1);
     DASSERT (Result.typespec().is_int() && NodeID.typespec().is_int());
     llvm::Value *ret = rop.ll.call_function ("osl_dict_next",
-                                               rop.sg_void_ptr(),
-                                               rop.llvm_load_value(NodeID));
+                                             rop.sg_void_ptr(),
+                                             rop.llvm_load_value(NodeID));
     rop.llvm_store_value (ret, Result);
     return true;
 }
@@ -3500,7 +3496,7 @@ LLVMGEN (llvm_gen_dict_value)
     args[3] = rop.ll.constant(Value.typespec().simpletype());
     // arg 4: pointer to Value
     args[4] = rop.llvm_void_ptr (Value);
-    llvm::Value *ret = rop.ll.call_function ("osl_dict_value", &args[0], 5);
+    llvm::Value *ret = rop.ll.call_function ("osl_dict_value", args);
     rop.llvm_store_value (ret, Result);
     return true;
 }
@@ -3537,7 +3533,7 @@ LLVMGEN (llvm_gen_split)
         args[3] = rop.ll.constant (Results.typespec().arraylength());
     }
     args[4] = rop.ll.constant (Results.typespec().arraylength());
-    llvm::Value *ret = rop.ll.call_function ("osl_split", &args[0], 5);
+    llvm::Value *ret = rop.ll.call_function ("osl_split", args);
     rop.llvm_store_value (ret, R);
     return true;
 }
@@ -3563,7 +3559,7 @@ LLVMGEN (llvm_gen_raytype)
         args[1] = rop.llvm_get_pointer (Name);
         func = "osl_raytype_name";
     }
-    llvm::Value *ret = rop.ll.call_function (func, args, 2);
+    llvm::Value *ret = rop.ll.call_function (func, args);
     rop.llvm_store_value (ret, Result);
     return true;
 }
@@ -3582,7 +3578,7 @@ LLVMGEN (llvm_gen_blackbody)
 
     llvm::Value* args[3] = { rop.sg_void_ptr(), rop.llvm_void_ptr(Result),
                              rop.llvm_load_value(Temperature) };
-    rop.ll.call_function (Strutil::format("osl_%s_vf",op.opname().c_str()).c_str(), args, 3);
+    rop.ll.call_function (Strutil::format("osl_%s_vf",op.opname()), args);
 
     // Punt, zero out derivs.
     // FIXME -- only of some day, someone truly needs blackbody() to
@@ -3607,9 +3603,7 @@ LLVMGEN (llvm_gen_luminance)
     bool deriv = C.has_derivs() && Result.has_derivs();
     llvm::Value* args[3] = { rop.sg_void_ptr(), rop.llvm_void_ptr(Result),
                              rop.llvm_void_ptr(C) };
-    rop.ll.call_function (deriv ? "osl_luminance_dfdv" : "osl_luminance_fv",
-                            args, 3);
-
+    rop.ll.call_function (deriv ? "osl_luminance_dfdv" : "osl_luminance_fv", args);
     if (Result.has_derivs() && !C.has_derivs())
         rop.llvm_zero_derivs (Result);
 
diff -purN a/src/liboslexec/llvm_instance.cpp b/src/liboslexec/llvm_instance.cpp
--- a/src/liboslexec/llvm_instance.cpp	2016-06-27 22:34:50.000000000 +0100
+++ b/src/liboslexec/llvm_instance.cpp	2016-06-27 22:37:25.000000000 +0100
@@ -167,8 +167,9 @@ void *
 helper_function_lookup (const std::string &name)
 {
     HelperFuncMap::const_iterator i = llvm_helper_function_map.find (name);
-    if (i == llvm_helper_function_map.end())
+    if (i == llvm_helper_function_map.end()) {
         return NULL;
+    }
     return (void *) i->second.function;
 }
 
@@ -452,9 +453,7 @@ BackendLLVM::llvm_assign_initial_value (
         args.push_back (ll.constant (sym.derivsize()));
         args.push_back (ll.void_ptr (userdata_initialized_ref(userdata_index)));
         args.push_back (ll.constant (userdata_index));
-        llvm::Value *got_userdata =
-            ll.call_function ("osl_bind_interpolated_param",
-                              &args[0], args.size());
+        llvm::Value *got_userdata = ll.call_function ("osl_bind_interpolated_param", args);
         if (shadingsys().debug_nan() && type.basetype == TypeDesc::FLOAT) {
             // check for NaN/Inf for float-based types
             int ncomps = type.numelements() * type.aggregate;
@@ -465,7 +464,7 @@ BackendLLVM::llvm_assign_initial_value (
                  ll.constant(0), ll.constant(ncomps),
                  ll.constant("<get_userdata>")
             };
-            ll.call_function ("osl_naninf_check", args, 10);
+            ll.call_function ("osl_naninf_check", args);
         }
         // We will enclose the subsequent initialization of default values
         // or init ops in an "if" so that the extra copies or code don't
@@ -559,7 +558,7 @@ BackendLLVM::llvm_generate_debugnan (con
                                 ncheck,
                                 ll.constant(op.opname())
                               };
-        ll.call_function ("osl_naninf_check", args, 10);
+        ll.call_function ("osl_naninf_check", args);
     }
 }
 
@@ -623,7 +622,7 @@ BackendLLVM::llvm_generate_debug_uninit
                                 offset,
                                 ncheck
                               };
-        ll.call_function ("osl_uninit_check", args, 15);
+        ll.call_function ("osl_uninit_check", args);
     }
 }
 
@@ -674,18 +673,14 @@ BackendLLVM::build_llvm_init ()
     // Make a group init function: void group_init(ShaderGlobals*, GroupData*)
     // Note that the GroupData* is passed as a void*.
     std::string unique_name = Strutil::format ("group_%d_init", group().id());
-    ll.current_function (
-           ll.make_function (unique_name, false,
-                             ll.type_void(), // return type
-                             llvm_type_sg_ptr(), llvm_type_groupdata_ptr()));
+    ll.make_function (unique_name, false,
+                      ll.type_void(), // return type
+                      llvm_type_sg_ptr(), llvm_type_groupdata_ptr());
 
     // Get shader globals and groupdata pointers
     m_llvm_shaderglobals_ptr = ll.current_function_arg(0); //arg_it++;
     m_llvm_groupdata_ptr = ll.current_function_arg(1); //arg_it++;
 
-    // Set up a new IR builder
-    llvm::BasicBlock *entry_bb = ll.new_basic_block (unique_name);
-    ll.new_builder (entry_bb);
 #if 0 /* helpful for debugging */
     if (llvm_debug()) {
         llvm_gen_debug_printf (Strutil::format("\n\n\n\nGROUP! %s",group().name()));
@@ -736,8 +731,6 @@ BackendLLVM::build_llvm_init ()
                   << " after llvm  = " 
                   << ll.bitcode_string(ll.current_function()) << "\n";
 
-    ll.end_builder();  // clear the builder
-
     return ll.current_function();
 }
 
@@ -748,25 +741,19 @@ BackendLLVM::build_llvm_instance (bool g
 {
     // Make a layer function: void layer_func(ShaderGlobals*, GroupData*)
     // Note that the GroupData* is passed as a void*.
-    std::string unique_layer_name = Strutil::format ("%s_%d", inst()->layername(), inst()->id());
 
     bool is_entry_layer = group().is_entry_layer(layer());
-    ll.current_function (
-           ll.make_function (unique_layer_name,
-                             !is_entry_layer, // fastcall for non-entry layer functions
-                             ll.type_void(), // return type
-                             llvm_type_sg_ptr(), llvm_type_groupdata_ptr()));
+    ll.make_function (layer_function_name(inst()),
+                      !is_entry_layer, // fastcall for non-entry layer functions
+                      ll.type_void(), // return type
+                      llvm_type_sg_ptr(), llvm_type_groupdata_ptr());
 
     // Get shader globals and groupdata pointers
     m_llvm_shaderglobals_ptr = ll.current_function_arg(0); //arg_it++;
     m_llvm_groupdata_ptr = ll.current_function_arg(1); //arg_it++;
 
-    llvm::BasicBlock *entry_bb = ll.new_basic_block (unique_layer_name);
     m_exit_instance_block = NULL;
 
-    // Set up a new IR builder
-    ll.new_builder (entry_bb);
-
     llvm::Value *layerfield = layer_run_ref(layer_remap(layer()));
     if (is_entry_layer && ! group().is_last_layer(layer())) {
         // For entry layers, we need an extra check to see if it already
@@ -835,7 +822,7 @@ BackendLLVM::build_llvm_instance (bool g
                      ll.constant(0), ll.constant(ncomps),
                      ll.constant("<none>")
                 };
-                ll.call_function ("osl_naninf_check", args, 10);
+                ll.call_function ("osl_naninf_check", args);
             }
         }
     }
@@ -911,12 +898,10 @@ BackendLLVM::build_llvm_instance (bool g
     ll.op_return();
 
     if (llvm_debug())
-        std::cout << "layer_func (" << unique_layer_name << ") "<< this->layer() 
+        std::cout << "layer_func (" << layer_function_name(inst()) << ") "<< this->layer() 
                   << "/" << group().nlayers() << " after llvm  = " 
                   << ll.bitcode_string(ll.current_function()) << "\n";
 
-    ll.end_builder();  // clear the builder
-
     return ll.current_function();
 }
 
@@ -939,7 +924,7 @@ BackendLLVM::initialize_llvm_group ()
     for (HelperFuncMap::iterator i = llvm_helper_function_map.begin(),
          e = llvm_helper_function_map.end(); i != e; ++i) {
         const char *funcname = i->first.c_str();
-        bool varargs = false;
+        LLVM_Util::HasVarArgs varargs = LLVM_Util::NoVarArgs;
         const char *types = i->second.argtypes;
         int advance;
         TypeSpec rettype = OSLCompilerImpl::type_from_code (types, &advance);
@@ -949,7 +934,7 @@ BackendLLVM::initialize_llvm_group ()
             TypeSpec t = OSLCompilerImpl::type_from_code (types, &advance);
             if (t.simpletype().basetype == TypeDesc::UNKNOWN) {
                 if (*types == '*')
-                    varargs = true;
+                    varargs = LLVM_Util::VarArgs;
                 else
                     ASSERT (0);
             } else {
@@ -957,7 +942,8 @@ BackendLLVM::initialize_llvm_group ()
             }
             types += advance;
         }
-        ll.make_function (funcname, false, llvm_type(rettype), params, varargs);
+        ll.declare_extern_function (funcname, llvm_type(rettype), params,
+                                    varargs);
     }
 
     // Needed for closure setup
@@ -990,22 +976,24 @@ BackendLLVM::run ()
 #endif
 
 #ifdef OSL_LLVM_NO_BITCODE
-    ll.module (ll.new_module ("llvm_ops"));
+    ll.new_module ("llvm_ops");
 #else
-    ll.module (ll.module_from_bitcode (osl_llvm_compiled_ops_block,
-                                       osl_llvm_compiled_ops_size,
-                                       "llvm_ops", &err));
+    string_view seed (osl_llvm_compiled_ops_block, osl_llvm_compiled_ops_size);
+    ll.module_from_bitcode (seed, "llvm_ops", &err);
+    // ll.new_module ("llvm_ops");
     if (err.length())
-        shadingcontext()->error ("ParseBitcodeFile returned '%s'\n", err.c_str());
+        shadingcontext()->error ("ParseBitcodeFile returned '%s'\n", err);
     ASSERT (ll.module());
 #endif
-
+    
+#if 0
     // Create the ExecutionEngine
     if (! ll.make_jit_execengine (&err)) {
-        shadingcontext()->error ("Failed to create engine: %s\n", err.c_str());
+        shadingcontext()->error ("Failed to create engine: %s\n", err);
         ASSERT (0);
         return;
     }
+#endif
 
     // End of mutex lock, for the OSL_LLVM_NO_BITCODE case
     }
@@ -1097,18 +1085,26 @@ BackendLLVM::run ()
         ll.write_bitcode_file (name.c_str());
     }
 
+    ll.module_done ();
+
     // Force the JIT to happen now and retrieve the JITed function pointers
     // for the initialization and all public entry points.
-    group().llvm_compiled_init ((RunLLVMGroupFunc) ll.getPointerToFunction(init_func));
+    group().llvm_compiled_init ((RunLLVMGroupFunc) ll.get_compiled_function(entry_function_names[0]));
     for (int layer = 0; layer < nlayers; ++layer) {
         llvm::Function* f = funcs[layer];
-        if (f && group().is_entry_layer (layer))
-            group().llvm_compiled_layer (layer, (RunLLVMGroupFunc) ll.getPointerToFunction(f));
+        if (f && group().is_entry_layer (layer)) {
+            string_view name (layer_function_name(group()[layer]));
+            ASSERT (ll.get_compiled_function(name));
+            group().llvm_compiled_layer (layer, (RunLLVMGroupFunc) ll.get_compiled_function(name));
+        }
     }
     if (group().num_entry_layers())
         group().llvm_compiled_version (NULL);
-    else
+    else {
+        string_view name (layer_function_name(group()[nlayers-1]));
+        group().llvm_compiled_layer (nlayers-1, (RunLLVMGroupFunc) ll.get_compiled_function(name));
         group().llvm_compiled_version (group().llvm_compiled_layer(nlayers-1));
+    }
 
     // Remove the IR for the group layer functions, we've already JITed it
     // and will never need the IR again.  This saves memory, and also saves
@@ -1122,10 +1118,10 @@ BackendLLVM::run ()
 
     // Free the exec and module to reclaim all the memory.  This definitely
     // saves memory, and has almost no effect on runtime.
-    ll.execengine (NULL);
+//    ll.execengine (NULL);
 
     // N.B. Destroying the EE should have destroyed the module as well.
-    ll.module (NULL);
+//    ll.module (NULL);
 
     m_stat_llvm_jit_time += timer.lap();
 
diff -purN a/src/liboslexec/llvm_test.cpp b/src/liboslexec/llvm_test.cpp
--- a/src/liboslexec/llvm_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/src/liboslexec/llvm_test.cpp	2016-06-27 22:37:25.000000000 +0100
@@ -0,0 +1,208 @@
+/*
+Copyright (c) 2009-2016 Sony Pictures Imageworks Inc., et al.
+All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+* Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+* Neither the name of Sony Pictures Imageworks nor the names of its
+  contributors may be used to endorse or promote products derived from
+  this software without specific prior written permission.
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <OpenImageIO/dassert.h>
+#include <OpenImageIO/argparse.h>
+
+#include <llvm/ADT/STLExtras.h>
+#include <llvm/Bitcode/ReaderWriter.h>
+#include <llvm/ExecutionEngine/ExecutionEngine.h>
+#include <llvm/ExecutionEngine/Orc/CompileUtils.h>
+#include <llvm/ExecutionEngine/RuntimeDyld.h>
+#include <llvm/ExecutionEngine/Orc/IRCompileLayer.h>
+#include <llvm/ExecutionEngine/Orc/LambdaResolver.h>
+#include <llvm/ExecutionEngine/Orc/ObjectLinkingLayer.h>
+#include <llvm/IR/DataLayout.h>
+#include <llvm/IR/IRBuilder.h>
+#include <llvm/IR/LegacyPassManager.h>
+#include <llvm/IR/LLVMContext.h>
+#include <llvm/IR/Mangler.h>
+#include <llvm/IR/Module.h>
+#include <llvm/IR/Verifier.h>
+#include <llvm/Support/DynamicLibrary.h>
+#include <llvm/Support/TargetSelect.h>
+#include <llvm/Target/TargetMachine.h>
+#include <llvm/Transforms/IPO.h>
+#include <llvm/Transforms/IPO/PassManagerBuilder.h>
+#include <llvm/Transforms/Scalar.h>
+#include <llvm/Transforms/Utils/UnifyFunctionExitNodes.h>
+
+
+
+static bool verbose = false;
+static bool debug = false;
+static int opt = -1;
+static bool orc = false;
+
+
+static void
+getargs (int argc, char *argv[])
+{
+    bool help = false;
+    OIIO::ArgParse ap;
+    ap.options ("llvmutil_test\n"
+                OIIO_INTRO_STRING "\n"
+                "Usage:  llvmutil_test [options]",
+                "--help", &help, "Print help message",
+                "-v", &verbose, "Verbose mode",
+                "--debug", &debug, "Debug mode",
+                "--opt %d", &opt, "Opt level (0=basic, 1-3=like clang)",
+                "--orc", &orc, "Use ORC JIT",
+                // "--iters %d", &iterations,
+                //     Strutil::format("Number of iterations (default: %d)", iterations).c_str(),
+                // "--trials %d", &ntrials, "Number of trials",
+                NULL);
+    if (ap.parse (argc, (const char**)argv) < 0) {
+        std::cerr << ap.geterror() << std::endl;
+        ap.usage ();
+        exit (EXIT_FAILURE);
+    }
+    if (help) {
+        ap.usage ();
+        exit (EXIT_FAILURE);
+    }
+}
+
+
+
+template <typename T>
+inline std::vector<T> singletonSet (T t)
+{
+    std::vector<T> Vec;
+    Vec.push_back(std::move(t));
+    return Vec;
+}
+
+
+std::string
+mangle (const std::string &Name, llvm::DataLayout &DL)
+{
+    std::string MangledName;
+    llvm::raw_string_ostream MangledNameStream (MangledName);
+    llvm::Mangler::getNameWithPrefix (MangledNameStream, Name, DL);
+    return MangledName;
+}
+
+
+
+extern "C" {
+// __attribute__ ((visibility ("default")))
+float sqr (float x) { return x*x; }
+}
+
+
+
+int
+main (int argc, char *argv[])
+{
+    getargs (argc, argv);
+
+    llvm::InitializeAllTargets();
+    llvm::InitializeAllTargetMCs();
+    llvm::InitializeAllAsmPrinters();
+    llvm::InitializeAllAsmParsers();
+    llvm::sys::DynamicLibrary::LoadLibraryPermanently (nullptr);
+    llvm::LLVMContext Context;
+    std::unique_ptr<llvm::TargetMachine> TM (llvm::EngineBuilder().selectTarget());
+    std::unique_ptr<llvm::DataLayout> DL;
+    DL.reset (new llvm::DataLayout (TM->createDataLayout()));
+    std::unique_ptr<llvm::ExecutionEngine> EE;
+    typedef llvm::orc::ObjectLinkingLayer<> ObjLayerT;
+    typedef llvm::orc::IRCompileLayer<ObjLayerT> CompileLayerT;
+    typedef CompileLayerT::ModuleSetHandleT ModuleHandleT;
+    ObjLayerT Objlayer;
+    CompileLayerT Compilelayer (Objlayer, llvm::orc::SimpleCompiler(*TM));
+    std::unique_ptr<llvm::Module> M (new llvm::Module("module", Context));
+    M->setDataLayout (*DL);
+
+    // Declare stub for external function sqr
+    auto type_float = llvm::Type::getFloatTy (Context);
+    llvm::Type* one_float[] = { type_float };
+    llvm::FunctionType *functype_ff = llvm::FunctionType::get (type_float, one_float, false);
+    llvm::Function::Create (functype_ff, llvm::Function::ExternalLinkage,
+                            "sqr", M.get());
+
+
+    // Create myfunc and generate its IR, which just calls sqr on its argument
+    llvm::Function *myfunc = llvm::Function::Create (functype_ff,
+                                                     llvm::Function::ExternalLinkage,
+                                                     "myfunc", M.get());
+    llvm::IRBuilder<> builder (Context);
+    auto block = llvm::BasicBlock::Create (Context, "", myfunc);
+    builder.SetInsertPoint (block);
+    llvm::Value *a = llvm::cast<llvm::Value>(myfunc->arg_begin());
+    llvm::Value *asq = builder.CreateCall (M->getFunction ("sqr"), a);
+    builder.CreateRet (asq);
+
+    // Set up compilation
+    if (orc) {
+        auto Resolver = llvm::orc::createLambdaResolver(
+            // External lookup functor
+            [&](const std::string &name) {
+                if (auto Sym = Compilelayer.findSymbol(name, true))
+                    return llvm::RuntimeDyld::SymbolInfo(Sym.getAddress(), Sym.getFlags());
+                // If not found as a symbol, look up in current process
+                if (auto Addr = llvm::RTDyldMemoryManager::getSymbolAddressInProcess(name))
+                    return llvm::RuntimeDyld::SymbolInfo(Addr, llvm::JITSymbolFlags::Exported);
+                return llvm::RuntimeDyld::SymbolInfo(nullptr);
+            },
+            // Dylib lookup functor
+            [&](const std::string &name) { return nullptr; }
+        );
+        Compilelayer.addModuleSet (singletonSet(std::move(M)),
+                                          llvm::make_unique<llvm::SectionMemoryManager>(),
+                                          std::move(Resolver));
+    } else {
+        // MCJIT
+        std::string engine_errors;
+        llvm::EngineBuilder engine_builder (std::move(M));
+        engine_builder.setEngineKind (llvm::EngineKind::JIT)
+                      .setOptLevel (llvm::CodeGenOpt::Default) // Aggressive?
+                      .setErrorStr (&engine_errors);
+        EE.reset (engine_builder.create());
+        if (! EE)
+            std::cout << engine_errors << "\n";
+        ASSERT (EE);
+        EE->finalizeObject ();
+    }
+
+    // Ask for a callable function (will JIT on demand)
+    typedef float (*FuncFloatFloat)(float);
+    FuncFloatFloat my_executable_function = NULL;
+    if (orc) {
+        auto ExprSymbol = Compilelayer.findSymbol (mangle("myfunc", *DL), true);
+        my_executable_function = (FuncFloatFloat) ExprSymbol.getAddress ();
+    } else {
+        my_executable_function = (FuncFloatFloat) EE->getFunctionAddress ("myfunc");
+    }
+
+    ASSERT (my_executable_function);
+    printf ("myfunc(42.0f) = %g\n",
+            (*my_executable_function)(42.0f));
+    ASSERT ((*my_executable_function)(42.0f) == sqr(42.0));
+}
diff -purN a/src/liboslexec/llvm_util.cpp b/src/liboslexec/llvm_util.cpp
--- a/src/liboslexec/llvm_util.cpp	2016-06-27 22:34:50.000000000 +0100
+++ b/src/liboslexec/llvm_util.cpp	2016-06-27 22:37:25.000000000 +0100
@@ -33,107 +33,466 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 #include "OSL/oslconfig.h"
 #include "OSL/llvm_util.h"
 
-#if OSL_LLVM_VERSION < 34
-#error "LLVM minimum version required for OSL is 3.4"
+#if OSL_LLVM_VERSION < 37
+#error "LLVM minimum version required for OSL is 3.7"
 #endif
 
-#if OSL_LLVM_VERSION >= 35 && OSL_CPLUSPLUS_VERSION < 11
-#error "LLVM >= 3.5 requires C++11 or newer"
-#endif
+#define USE_ORC_JIT (OSL_LLVM_VERSION >= 37)
 
-// Use MCJIT for LLVM 3.6 and beyind, old JIT for earlier
-#define USE_MCJIT   (OSL_LLVM_VERSION >= 36)
-#define USE_OLD_JIT (OSL_LLVM_VERSION <  36)
-
-#include <llvm/IR/Constants.h>
-#include <llvm/IR/DerivedTypes.h>
-#include <llvm/IR/Instructions.h>
+#include <llvm/ADT/STLExtras.h>
+#include <llvm/Bitcode/ReaderWriter.h>
+#include <llvm/ExecutionEngine/ExecutionEngine.h>
+#include <llvm/ExecutionEngine/RuntimeDyld.h>
+#include <llvm/IR/DataLayout.h>
 #include <llvm/IR/Intrinsics.h>
-#include <llvm/IR/Module.h>
-#include <llvm/IR/LLVMContext.h>
 #include <llvm/IR/IRBuilder.h>
-#include <llvm/IR/DataLayout.h>
-#if OSL_LLVM_VERSION >= 35
-#  include <llvm/Linker/Linker.h>
-#  include <llvm/Support/FileSystem.h>
-#else
-#  include <llvm/Linker.h>
-#endif
-#include <llvm/Support/ErrorOr.h>
 #include <llvm/IR/LegacyPassManager.h>
-#include <llvm/Support/TargetRegistry.h>
-
-#include <llvm/Bitcode/ReaderWriter.h>
-#include <llvm/Support/ManagedStatic.h>
-#include <llvm/Support/MemoryBuffer.h>
-#include <llvm/ExecutionEngine/GenericValue.h>
-#if USE_MCJIT
-#  include <llvm/ExecutionEngine/MCJIT.h>
-#endif
-#if USE_OLD_JIT
-#  include <llvm/ExecutionEngine/JIT.h>
-#  include <llvm/ExecutionEngine/JITMemoryManager.h>
-#endif
-#include <llvm/Support/raw_ostream.h>
+#include <llvm/IR/LLVMContext.h>
+#include <llvm/IR/Mangler.h>
+#include <llvm/IR/Module.h>
+#include <llvm/IR/Verifier.h>
+#include <llvm/Support/DynamicLibrary.h>
 #include <llvm/Support/TargetSelect.h>
-#include <llvm/Support/PrettyStackTrace.h>
-#if OSL_LLVM_VERSION >= 35
-#  include <llvm/IR/Verifier.h>
-#else
-#  include <llvm/Analysis/Verifier.h>
-#endif
-#include <llvm/Target/TargetOptions.h>
-#include <llvm/Transforms/Scalar.h>
+#include <llvm/Target/TargetMachine.h>
 #include <llvm/Transforms/IPO.h>
-#include <llvm/Transforms/Utils/UnifyFunctionExitNodes.h>
 #include <llvm/Transforms/IPO/PassManagerBuilder.h>
+#include <llvm/Transforms/Scalar.h>
+#include <llvm/Transforms/Utils/UnifyFunctionExitNodes.h>
 
-OSL_NAMESPACE_ENTER
+#if USE_ORC_JIT
+#include <llvm/ExecutionEngine/Orc/CompileUtils.h>
+#include <llvm/ExecutionEngine/Orc/IRCompileLayer.h>
+#include <llvm/ExecutionEngine/Orc/LambdaResolver.h>
+#include <llvm/ExecutionEngine/Orc/ObjectLinkingLayer.h>
+#endif
 
-namespace pvt {
 
-#if USE_OLD_JIT
-using llvm::JITMemoryManager;
-// #else
-// typedef JITMemoryManager;
-#endif
+OSL_NAMESPACE_ENTER
 
 namespace {
 static OIIO::spin_mutex llvm_global_mutex;
-static bool setup_done = false;
-static boost::thread_specific_ptr<LLVM_Util::PerThreadInfo> perthread_infos;
-#if USE_OLD_JIT
-static std::vector<shared_ptr<JITMemoryManager> > jitmm_hold;
-#endif
+static bool llvm_setup_done = false;
+
+
+// Make a globally unique name given a prefix.
+std::string
+make_unique_name (string_view prefix = "___")
+{
+    static OIIO::atomic_int counter (0);
+    int c = counter++;
+    return OIIO::Strutil::format ("%s%d", prefix, c);
+}
+
+
+template <typename T>
+static std::vector<T> singletonSet (T t)
+{
+    std::vector<T> Vec;
+    Vec.push_back(std::move(t));
+    return Vec;
+}
+
+
+// Quick conversion of string_view to llvm::StringRef.
+inline llvm::StringRef SR (string_view s) {
+    return llvm::StringRef (s.data(), s.size());
+}
+
+// Quick conversion of array_view to llvm::ArrayRef.
+template <typename T>
+inline llvm::ArrayRef<T> AR (OIIO::array_view<T> t) {
+    return llvm::ArrayRef<T> (t.data(), t.size());
+}
+
+// Quick conversion of array_view of const objects to llvm::ArrayRef.
+template <typename T>
+inline llvm::ArrayRef<T> AR (OIIO::array_view<const T> t) {
+    return llvm::ArrayRef<T> (t.data(), t.size());
+}
+
 };
 
 
 
 
-// We hold certain things (LLVM context and custom JIT memory manager)
-// per thread and retained across LLVM_Util invocations.  We are
-// intentionally "leaking" them.
-struct LLVM_Util::PerThreadInfo {
-    PerThreadInfo () : llvm_context(NULL), llvm_jitmm(NULL) {}
-    ~PerThreadInfo () {
-        delete llvm_context;
-        // N.B. Do NOT delete the jitmm -- another thread may need the
-        // code! Don't worry, we stashed a pointer in jitmm_hold.
-    }
-    static void destroy (PerThreadInfo *threadinfo) { delete threadinfo; }
-    static PerThreadInfo *get () {
-        PerThreadInfo *p = perthread_infos.get ();
-        if (! p) {
-            p = new PerThreadInfo();
-            perthread_infos.reset (p);
+// LLVM_Util::Impl holds all the LLVM data structures we didn't want to have
+// to expose to user code in llvm_util.h, and the methods that need intimate
+// access to those data.
+//
+// Methods that are simply "pass-through" from LLVM_Util (i.e., the
+// LLVM_Util::foo() just calls impl->foo()) are not prefixed with a comment,
+// just read the commends in llvm_util.h for details.
+//
+class LLVM_Util::Impl {
+public:
+    typedef llvm::orc::ObjectLinkingLayer<> ObjLayerT;
+    typedef llvm::orc::IRCompileLayer<ObjLayerT> CompileLayerT;
+    typedef CompileLayerT::ModuleSetHandleT ModuleHandleT;
+    // friend class LLVM_Util;
+
+    Impl () {
+        initialize_llvm ();
+        m_llvm_context.reset (new llvm::LLVMContext());
+        // FIXME: Can we use LLVMGetGlobalContext()? What are the
+        // implications of sharing a context across threads or LLVM_Util
+        // instances?
+        setup_llvm_datatype_aliases ();
+        m_llvm_target_machine.reset (llvm::EngineBuilder().selectTarget());
+        m_llvm_data_layout.reset (
+            new llvm::DataLayout (m_llvm_target_machine->createDataLayout()));
+
+        // Set up ORC JIT. Can be used for many modules.
+        m_orc_compilelayer.reset (
+            new CompileLayerT(m_orc_objlayer,
+                              llvm::orc::SimpleCompiler(*m_llvm_target_machine)));
+    }
+
+    ~Impl () {}
+
+    typedef LLVM_Util::IRBuilder IRBuilder;
+
+    /// Set debug level
+    void debug (int d) { m_debug = d; }
+    int debug () const { return m_debug; }
+
+    void orc_jit (bool enable) { m_use_orc_jit = enable; }
+    bool orc_jit () const { return m_use_orc_jit; }
+
+    /// Return a reference to the current context.
+    llvm::LLVMContext &context () const { return *m_llvm_context; }
+
+    llvm::Module *module () { return m_llvm_module.get(); }
+    std::unique_ptr<llvm::Module> take_module () { return std::move(m_llvm_module); }
+
+    /// Create a new empty module, make it the current module, return a
+    /// pointer to it.
+    llvm::Module *new_module (string_view id) {
+        m_llvm_module.reset (new llvm::Module(make_unique_name(id), context()));
+        m_llvm_module->setDataLayout (*m_llvm_data_layout);
+        return m_llvm_module.get();
+    }
+
+    /// Create a new module, populated with functions from the buffer
+    /// bitcode[0..size-1], make it the current module.  The name identifies
+    /// the buffer.  If err is not NULL, error messages will be stored
+    /// there.
+    llvm::Module *module_from_bitcode (string_view bitcode, string_view name,
+                                       std::string *err=NULL) {
+        if (err)
+            err->clear();
+        llvm::MemoryBufferRef buf = llvm::MemoryBufferRef(SR(bitcode), SR(name));
+        llvm::ErrorOr<std::unique_ptr<llvm::Module> > ModuleOrErr = llvm::parseBitcodeFile (buf, context());
+        if (std::error_code EC = ModuleOrErr.getError())
+            if (err)
+              *err = EC.message();
+        m_llvm_module = std::move (ModuleOrErr.get());
+        return m_llvm_module.get();
+        // Debugging: print all functions in the module
+        // for (llvm::Module::iterator i = m->begin(); i != m->end(); ++i)
+        //     std::cout << "  found " << i->getName().data() << "\n";
+        //    return m;
+    }
+
+
+    /// Set up a new current function that subsequent basic blocks will
+    /// be added to.
+    void current_function (llvm::Function *func) { m_current_function = func; }
+
+    /// Return a ptr to the current function we're generating.
+    llvm::Function *current_function () const { return m_current_function; }
+
+    /// Return the value ptr for the a-th argument of the current function.
+    llvm::Value *current_function_arg (int a) {
+        DASSERT (m_current_function);
+        llvm::Function::arg_iterator arg_it = m_current_function->arg_begin();
+        for (int i = 0;  i < a;  ++i)
+            ++arg_it;
+        return llvm::cast<llvm::Value>(arg_it);
+    }
+
+
+    /// Create a new IR builder with the given block as entry point. If
+    /// block is NULL, a new basic block for the current function will be
+    /// created.
+    void new_builder (llvm::BasicBlock *block=NULL) {
+        if (! block)
+            block = llvm::BasicBlock::Create (context(), "" /*name*/, current_function());
+        m_builder.reset (new IRBuilder (block));
+    }
+
+    /// Return the current IR builder.
+    IRBuilder &builder () {
+        DASSERT (m_builder);
+        return *m_builder;
+    }
+
+    /// Return a pointer to the current ExecutionEngine.  Create a JITing
+    /// ExecutionEngine if one isn't already set up.
+    llvm::ExecutionEngine *execengine () {
+        return m_llvm_exec.get();
+    }
+
+    /// Setup LLVM optimization passes.
+    void setup_optimization_passes (int optlevel);
+
+    /// Run the optimization passes.
+    void do_optimize () {
+        if (! m_llvm_module_passes)        // If caller didn't set up,
+            setup_optimization_passes (0); //   use basic default opt.
+        m_llvm_module_passes->run (*module());
+    }
+
+    /// Wrap ExecutionEngine::InstallLazyFunctionCreator.
+    void InstallLazyFunctionCreator (LLVM_Util::FunctionResolver P) {
+        m_lazy_func_resolver = P;
+    }
+
+    std::string mangle (string_view name) {
+        std::string MangledName;
+        llvm::raw_string_ostream MangledNameStream (MangledName);
+        llvm::Mangler::getNameWithPrefix (MangledNameStream, SR(name),
+                                          *m_llvm_data_layout);
+        return MangledName;
+    }
+
+    ModuleHandleT addModule (std::unique_ptr<llvm::Module> M) {
+        // We need a memory manager to allocate memory and resolve symbols
+        // for this new module. Create one that resolves symbols by looking
+        // back into the JIT. (Stolen from LLVM Kaleidescope example.)
+        auto Resolver = llvm::orc::createLambdaResolver(
+                // External lookup functor
+                [&](const std::string &name) {
+                    std::cout << "Resolver '" << name << "'\n";
+                    if (auto Sym = findMangledSymbol(name)) {
+                        std::cout << " resolver returned a sym\n";
+                        return llvm::RuntimeDyld::SymbolInfo(Sym.getAddress(),
+                                                             Sym.getFlags());
+                    }
+                    if (auto Sym = findUnmangledSymbol(name))
+                        return llvm::RuntimeDyld::SymbolInfo(Sym.getAddress(),
+                                                             Sym.getFlags());
+                    if (auto Sym = findDemangledSymbol(name))
+                        return llvm::RuntimeDyld::SymbolInfo(Sym.getAddress(),
+                                                             Sym.getFlags());
+                    if (m_lazy_func_resolver) {
+                        void* addr = (*m_lazy_func_resolver)(name);
+                        std::cout << "  used func_resolver, addr=" << addr << "\n";
+                        if (addr)
+                            return llvm::RuntimeDyld::SymbolInfo(uint64_t(addr),
+                                                                 llvm::JITSymbolFlags::None);
+                    }
+                    std::cout << "   checking process for " << name << "\n";
+                    if (auto Addr = llvm::RTDyldMemoryManager::getSymbolAddressInProcess(name)) {
+                        std::cout << "   FOUND " << name << "\n";
+                        return llvm::RuntimeDyld::SymbolInfo(Addr, llvm::JITSymbolFlags::Exported);
+                    }
+                        std::cout << "   nnot found " << name << "\n";
+                    return llvm::RuntimeDyld::SymbolInfo(nullptr);
+                },
+                // Dylib lookup functor
+                [&](const std::string &name) {
+                    std::cout << "Dylib Resolver '" << name << "'\n";
+                    return nullptr;
+                }
+            );
+        auto H = m_orc_compilelayer->addModuleSet (singletonSet(std::move(M)),
+                                                   llvm::make_unique<llvm::SectionMemoryManager>(),
+                                                   std::move(Resolver));
+        m_module_handles.push_back (H);
+        return H;
+    }
+
+    void removeModule (ModuleHandleT H) {
+        m_module_handles.erase (std::find(m_module_handles.begin(), m_module_handles.end(), H));
+        m_orc_compilelayer->removeModuleSet(H);
+    }
+
+    llvm::orc::JITSymbol findMangledSymbol (string_view name) {
+        // for (auto H : llvm::make_range(m_module_handles.rbegin(), m_module_handles.rend()))
+        //     if (auto Sym = m_orc_compilelayer->findSymbolIn(H, name, true))
+        //         return Sym;
+        if (auto sym = m_orc_compilelayer->findSymbol (name, true))
+            return sym;
+        // std::cout << "Second try on " << name << "\n";
+        // If we can't find the symbol in the JIT, try looking in the host process.
+        if (auto symAddr = llvm::RTDyldMemoryManager::getSymbolAddressInProcess(name)) {
+            // std::cout << " FOUND mangled in process " << name << "\n";
+            return llvm::orc::JITSymbol (symAddr, llvm::JITSymbolFlags::Exported);
         }
-        return p;
+        // std::cout << "  whoa, failed second try\n";
+        return llvm::orc::JITSymbol(nullptr);
     }
 
-    llvm::LLVMContext *llvm_context;
-    llvm::JITMemoryManager *llvm_jitmm;
-};
+    llvm::orc::JITSymbol findUnmangledSymbol (string_view name) {
+        return findMangledSymbol (mangle (name));
+    }
 
+    llvm::orc::JITSymbol findDemangledSymbol (string_view name) {
+        while (name.size() && name[0] == '_') {
+            name.remove_prefix (1);
+            if (auto s = findMangledSymbol (name))
+                return s;
+        }
+        return nullptr;
+    }
+
+    void module_done () {
+        if (orc_jit()) {
+            /*auto modulehandle =*/ addModule (take_module());
+        } else {
+            std::string engine_errors;
+            llvm::EngineBuilder engine_builder (take_module());
+            engine_builder.setEngineKind (llvm::EngineKind::JIT)
+                          .setOptLevel (llvm::CodeGenOpt::Default) // Aggressive?
+                          .setErrorStr (&engine_errors);
+            m_llvm_exec.reset (engine_builder.create());
+            // FIXME: check for errors here, report
+            m_llvm_exec->InstallLazyFunctionCreator (m_lazy_func_resolver);
+            m_llvm_exec->finalizeObject ();
+        }
+    }
+
+    void * get_compiled_function (string_view name) {
+        if (orc_jit()) {
+            auto ExprSymbol = findUnmangledSymbol (name);
+            return (void *) ExprSymbol.getAddress ();
+        } else {
+            ASSERT (m_llvm_exec);
+            return (void *) m_llvm_exec->getFunctionAddress (name);
+        }
+    }
+
+    /// Create a new LLVM basic block (for the current function) and return
+    /// its handle. If an IRBuilder hasn't yet been created, do that also.
+    /// If insert is true, set the insertion point for new IR ops to be the
+    /// new BB.
+    llvm::BasicBlock *new_basic_block (string_view name="",
+                                       bool insert=false) {
+        // Create an IRBuilder if it hasn't already been done, since if the
+        // caller creates a block, surely they're about to start adding
+        // code.
+        if (! m_builder)
+            m_builder.reset (new IRBuilder(context()));
+        ASSERT (m_current_function);
+        auto block = llvm::BasicBlock::Create (context(), SR(name), current_function());
+        if (insert)
+            m_builder->SetInsertPoint (block);
+        return block;
+    }
+
+    /// Save the return block pointer when entering a function. If
+    /// after==NULL, generate a new basic block for where to go after the
+    /// function return.  Return the after BB.
+    llvm::BasicBlock *push_function (llvm::BasicBlock *after=NULL) {
+        if (! after)
+            after = new_basic_block ();
+        m_return_block.push_back (after);
+        return after;
+    }
+
+    /// Pop basic return destination when exiting a function.  This includes
+    /// resetting the IR insertion point to the block following the
+    /// corresponding function call.
+    void pop_function () {
+        ASSERT (! m_return_block.empty());
+        builder().SetInsertPoint (m_return_block.back());
+        m_return_block.pop_back ();
+    }
+
+    /// Return the basic block where we go after returning from the current
+    /// function.
+    llvm::BasicBlock *return_block () const {
+        ASSERT (! m_return_block.empty());
+        return m_return_block.back();
+    }
+
+    /// Save the basic block pointers when entering a loop.
+    void push_loop (llvm::BasicBlock *step, llvm::BasicBlock *after) {
+        m_loop_step_block.push_back (step);
+        m_loop_after_block.push_back (after);
+    }
+
+    /// Pop basic block pointers when exiting a loop.
+    void pop_loop () {
+        ASSERT (! m_loop_step_block.empty() && ! m_loop_after_block.empty());
+        m_loop_step_block.pop_back ();
+        m_loop_after_block.pop_back ();
+    }
+
+    /// Return the basic block of the current loop's 'step' instructions.
+    llvm::BasicBlock *loop_step_block () const {
+        ASSERT (! m_loop_step_block.empty());
+        return m_loop_step_block.back();
+    }
+
+    /// Return the basic block of the current loop's exit point.
+    llvm::BasicBlock *loop_after_block () const {
+        ASSERT (! m_loop_after_block.empty());
+        return m_loop_after_block.back();
+    }
+
+    llvm::Type *type_float() const { return m_llvm_type_float; }
+    llvm::Type *type_int() const { return m_llvm_type_int; }
+    llvm::Type *type_addrint() const { return m_llvm_type_addrint; }
+    llvm::Type *type_bool() const { return m_llvm_type_bool; }
+    llvm::Type *type_char() const { return m_llvm_type_char; }
+    llvm::Type *type_longlong() const { return m_llvm_type_longlong; }
+    llvm::Type *type_void() const { return m_llvm_type_void; }
+    llvm::Type *type_triple() const { return m_llvm_type_triple; }
+    llvm::Type *type_matrix() const { return m_llvm_type_matrix; }
+    llvm::Type *type_typedesc() const { return m_llvm_type_longlong; }
+    llvm::PointerType *type_void_ptr() const { return m_llvm_type_void_ptr; }
+    llvm::PointerType *type_string() { return m_llvm_type_char_ptr; }
+    llvm::PointerType *type_ustring_ptr() const { return m_llvm_type_ustring_ptr; }
+    llvm::PointerType *type_char_ptr() const { return m_llvm_type_char_ptr; }
+    llvm::PointerType *type_int_ptr() const { return m_llvm_type_int_ptr; }
+    llvm::PointerType *type_float_ptr() const { return m_llvm_type_float_ptr; }
+    llvm::PointerType *type_triple_ptr() const { return m_llvm_type_triple_ptr; }
+    llvm::PointerType *type_matrix_ptr() const { return m_llvm_type_matrix_ptr; }
+
+    static size_t total_jit_memory_held ();
+
+private:
+
+    void initialize_llvm ();
+    void setup_llvm_datatype_aliases ();
+
+    std::unique_ptr<llvm::LLVMContext> m_llvm_context;
+    std::unique_ptr<llvm::Module> m_llvm_module;
+    std::unique_ptr<llvm::TargetMachine> m_llvm_target_machine;
+    std::unique_ptr<llvm::DataLayout> m_llvm_data_layout;
+    std::unique_ptr<IRBuilder> m_builder;
+    std::unique_ptr<llvm::ExecutionEngine> m_llvm_exec;
+    llvm::Function *m_current_function = NULL;
+    std::unique_ptr <llvm::legacy::PassManager> m_llvm_module_passes;
+    std::unique_ptr <llvm::legacy::FunctionPassManager> m_llvm_func_passes;
+    ObjLayerT m_orc_objlayer;
+    std::unique_ptr<CompileLayerT> m_orc_compilelayer;
+    std::vector<ModuleHandleT> m_module_handles;
+    FunctionResolver m_lazy_func_resolver = NULL;
+    std::vector<llvm::BasicBlock *> m_return_block;     // stack for func call
+    std::vector<llvm::BasicBlock *> m_loop_after_block; // stack for break
+    std::vector<llvm::BasicBlock *> m_loop_step_block;  // stack for continue
+
+    llvm::Type *m_llvm_type_float = NULL;
+    llvm::Type *m_llvm_type_int = NULL;
+    llvm::Type *m_llvm_type_addrint = NULL;
+    llvm::Type *m_llvm_type_bool = NULL;
+    llvm::Type *m_llvm_type_char = NULL;
+    llvm::Type *m_llvm_type_longlong = NULL;
+    llvm::Type *m_llvm_type_void = NULL;
+    llvm::Type *m_llvm_type_triple = NULL;
+    llvm::Type *m_llvm_type_matrix = NULL;
+    llvm::PointerType *m_llvm_type_void_ptr = NULL;
+    llvm::PointerType *m_llvm_type_ustring_ptr = NULL;
+    llvm::PointerType *m_llvm_type_char_ptr = NULL;
+    llvm::PointerType *m_llvm_type_int_ptr = NULL;
+    llvm::PointerType *m_llvm_type_float_ptr = NULL;
+    llvm::PointerType *m_llvm_type_triple_ptr = NULL;
+    llvm::PointerType *m_llvm_type_matrix_ptr = NULL;
+    int m_debug = 0;
+    bool m_use_orc_jit = false;
+};
 
 
 
@@ -156,343 +515,170 @@ LLVM_Util::total_jit_memory_held ()
 
 
 
-#if USE_OLD_JIT
-
-/// OSL_Dummy_JITMemoryManager - Create a shell that passes on requests
-/// to a real JITMemoryManager underneath, but can be retained after the
-/// dummy is destroyed.  Also, we don't pass along any deallocations.
-class OSL_Dummy_JITMemoryManager : public llvm::JITMemoryManager {
-protected:
-    llvm::JITMemoryManager *mm;  // the real one
-public:
-    OSL_Dummy_JITMemoryManager(llvm::JITMemoryManager *realmm) : mm(realmm) { HasGOT = realmm->isManagingGOT(); }
-    virtual ~OSL_Dummy_JITMemoryManager() {}
-    virtual void setMemoryWritable() { mm->setMemoryWritable(); }
-    virtual void setMemoryExecutable() { mm->setMemoryExecutable(); }
-    virtual void setPoisonMemory(bool poison) { mm->setPoisonMemory(poison); }
-    virtual void AllocateGOT() { ASSERT(HasGOT == false); ASSERT(HasGOT == mm->isManagingGOT()); mm->AllocateGOT(); HasGOT = true; ASSERT(HasGOT == mm->isManagingGOT()); }
-    virtual uint8_t *getGOTBase() const { return mm->getGOTBase(); }
-    virtual uint8_t *startFunctionBody(const llvm::Function *F,
-                                       uintptr_t &ActualSize) {
-        return mm->startFunctionBody (F, ActualSize);
-    }
-    virtual uint8_t *allocateStub(const llvm::GlobalValue* F, unsigned StubSize,
-                                  unsigned Alignment) {
-        return mm->allocateStub (F, StubSize, Alignment);
-    }
-    virtual void endFunctionBody(const llvm::Function *F,
-                                 uint8_t *FunctionStart, uint8_t *FunctionEnd) {
-        mm->endFunctionBody (F, FunctionStart, FunctionEnd);
-    }
-    virtual uint8_t *allocateSpace(intptr_t Size, unsigned Alignment) {
-        return mm->allocateSpace (Size, Alignment);
-    }
-    virtual uint8_t *allocateGlobal(uintptr_t Size, unsigned Alignment) {
-        return mm->allocateGlobal (Size, Alignment);
-    }
-    virtual void deallocateFunctionBody(void *Body) {
-        // DON'T DEALLOCATE mm->deallocateFunctionBody (Body);
-    }
-    virtual bool CheckInvariants(std::string &s) {
-        return mm->CheckInvariants(s);
-    }
-    virtual size_t GetDefaultCodeSlabSize() {
-        return mm->GetDefaultCodeSlabSize();
-    }
-    virtual size_t GetDefaultDataSlabSize() {
-        return mm->GetDefaultDataSlabSize();
-    }
-    virtual size_t GetDefaultStubSlabSize() {
-        return mm->GetDefaultStubSlabSize();
-    }
-    virtual unsigned GetNumCodeSlabs() { return mm->GetNumCodeSlabs(); }
-    virtual unsigned GetNumDataSlabs() { return mm->GetNumDataSlabs(); }
-    virtual unsigned GetNumStubSlabs() { return mm->GetNumStubSlabs(); }
-
-    virtual void *getPointerToNamedFunction(const std::string &Name,
-                                            bool AbortOnFailure = true) {
-        return mm->getPointerToNamedFunction (Name, AbortOnFailure);
-    }
-    virtual uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,
-                             unsigned SectionID, llvm::StringRef SectionName) {
-        return mm->allocateCodeSection(Size, Alignment, SectionID, SectionName);
-    }
-    virtual uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,
-                             unsigned SectionID, llvm::StringRef SectionName,
-                             bool IsReadOnly) {
-        return mm->allocateDataSection(Size, Alignment, SectionID,
-                                       SectionName, IsReadOnly);
-    }
-    virtual void registerEHFrames(uint8_t *Addr, uint64_t LoadAddr, size_t Size) {
-        mm->registerEHFrames (Addr, LoadAddr, Size);
-    }
-    virtual void deregisterEHFrames(uint8_t *Addr, uint64_t LoadAddr, size_t Size) {
-        mm->deregisterEHFrames(Addr, LoadAddr, Size);
-    }
-    virtual uint64_t getSymbolAddress(const std::string &Name) {
-        return mm->getSymbolAddress (Name);
-    }
-    virtual void notifyObjectLoaded(llvm::ExecutionEngine *EE, const llvm::ObjectImage *oi) {
-        mm->notifyObjectLoaded (EE, oi);
-    }
-    virtual bool finalizeMemory(std::string *ErrMsg = 0) {
-        return mm->finalizeMemory (ErrMsg);
-    }
-};
-
-#endif
-
-
+void
+LLVM_Util::Impl::initialize_llvm ()
+{
+    OIIO::spin_lock lock (llvm_global_mutex);
+    if (llvm_setup_done)
+        return;
+    // Some global LLVM initialization for the first thread that
+    // gets here.
 
+    llvm::InitializeAllTargets();
+    // llvm::InitializeAllTargetInfos();
+    llvm::InitializeAllTargetMCs();
+    llvm::InitializeAllAsmPrinters();
+    llvm::InitializeAllAsmParsers();
+    // llvm::InitializeAllDisassemblers();
 
-LLVM_Util::LLVM_Util (int debuglevel)
-    : m_debug(debuglevel), m_thread(NULL),
-      m_llvm_context(NULL), m_llvm_module(NULL),
-      m_builder(NULL), m_llvm_jitmm(NULL),
-      m_current_function(NULL),
-      m_llvm_module_passes(NULL), m_llvm_func_passes(NULL),
-      m_llvm_exec(NULL)
-{
-    SetupLLVM ();
-    m_thread = PerThreadInfo::get();
-    ASSERT (m_thread);
-
-    {
-        OIIO::spin_lock lock (llvm_global_mutex);
-        if (! m_thread->llvm_context)
-            m_thread->llvm_context = new llvm::LLVMContext();
+    // This is necessary to make sure that we can find symbols in our
+    // own executable.
+    llvm::sys::DynamicLibrary::LoadLibraryPermanently (nullptr);
 
-#if USE_OLD_JIT
-        if (! m_thread->llvm_jitmm) {
-            m_thread->llvm_jitmm = llvm::JITMemoryManager::CreateDefaultMemManager();
-            ASSERT (m_thread->llvm_jitmm);
-            jitmm_hold.push_back (shared_ptr<llvm::JITMemoryManager>(m_thread->llvm_jitmm));
+#if 0
+    if (debug()) {
+        for (llvm::TargetRegistry::iterator t = llvm::TargetRegistry::begin();
+             t != llvm::TargetRegistry::end();  ++t) {
+            std::cout << "Target: '" << t->getName() << "' "
+                      << t->getShortDescription() << "\n";
         }
-        m_llvm_jitmm = new OSL_Dummy_JITMemoryManager(m_thread->llvm_jitmm);
-#endif
+        std::cout << "\n";
     }
+#endif
+
+    llvm_setup_done = true;
+}
 
-    m_llvm_context = m_thread->llvm_context;
 
+
+void
+LLVM_Util::Impl::setup_llvm_datatype_aliases ()
+{
     // Set up aliases for types we use over and over
-    m_llvm_type_float = (llvm::Type *) llvm::Type::getFloatTy (*m_llvm_context);
-    m_llvm_type_int = (llvm::Type *) llvm::Type::getInt32Ty (*m_llvm_context);
+    llvm::LLVMContext &ctx (*m_llvm_context);
+    m_llvm_type_float = (llvm::Type *) llvm::Type::getFloatTy (ctx);
+    m_llvm_type_int = (llvm::Type *) llvm::Type::getInt32Ty (ctx);
     if (sizeof(char *) == 4)
-        m_llvm_type_addrint = (llvm::Type *) llvm::Type::getInt32Ty (*m_llvm_context);
+        m_llvm_type_addrint = (llvm::Type *) llvm::Type::getInt32Ty (ctx);
     else
-        m_llvm_type_addrint = (llvm::Type *) llvm::Type::getInt64Ty (*m_llvm_context);
-    m_llvm_type_int_ptr = (llvm::PointerType *) llvm::Type::getInt32PtrTy (*m_llvm_context);
-    m_llvm_type_bool = (llvm::Type *) llvm::Type::getInt1Ty (*m_llvm_context);
-    m_llvm_type_char = (llvm::Type *) llvm::Type::getInt8Ty (*m_llvm_context);
-    m_llvm_type_longlong = (llvm::Type *) llvm::Type::getInt64Ty (*m_llvm_context);
-    m_llvm_type_void = (llvm::Type *) llvm::Type::getVoidTy (*m_llvm_context);
-    m_llvm_type_char_ptr = (llvm::PointerType *) llvm::Type::getInt8PtrTy (*m_llvm_context);
-    m_llvm_type_float_ptr = (llvm::PointerType *) llvm::Type::getFloatPtrTy (*m_llvm_context);
+        m_llvm_type_addrint = (llvm::Type *) llvm::Type::getInt64Ty (ctx);
+    m_llvm_type_int_ptr = (llvm::PointerType *) llvm::Type::getInt32PtrTy (ctx);
+    m_llvm_type_bool = (llvm::Type *) llvm::Type::getInt1Ty (ctx);
+    m_llvm_type_char = (llvm::Type *) llvm::Type::getInt8Ty (ctx);
+    m_llvm_type_longlong = (llvm::Type *) llvm::Type::getInt64Ty (ctx);
+    m_llvm_type_void = (llvm::Type *) llvm::Type::getVoidTy (ctx);
+    m_llvm_type_char_ptr = (llvm::PointerType *) llvm::Type::getInt8PtrTy (ctx);
+    m_llvm_type_float_ptr = (llvm::PointerType *) llvm::Type::getFloatPtrTy (ctx);
     m_llvm_type_ustring_ptr = (llvm::PointerType *) llvm::PointerType::get (m_llvm_type_char_ptr, 0);
     m_llvm_type_void_ptr = m_llvm_type_char_ptr;
 
     // A triple is a struct composed of 3 floats
     std::vector<llvm::Type*> triplefields(3, m_llvm_type_float);
-    m_llvm_type_triple = type_struct (triplefields, "Vec3");
+    m_llvm_type_triple = llvm::StructType::create(context(), triplefields, "Vec3");
     m_llvm_type_triple_ptr = (llvm::PointerType *) llvm::PointerType::get (m_llvm_type_triple, 0);
 
     // A matrix is a struct composed 16 floats
     std::vector<llvm::Type*> matrixfields(16, m_llvm_type_float);
-    m_llvm_type_matrix = type_struct (matrixfields, "Matrix4");
+    m_llvm_type_matrix = llvm::StructType::create(context(), matrixfields, "Matrix4");
     m_llvm_type_matrix_ptr = (llvm::PointerType *) llvm::PointerType::get (m_llvm_type_matrix, 0);
 }
 
 
 
-LLVM_Util::~LLVM_Util ()
+
+LLVM_Util::LLVM_Util (int debuglevel)
+    : m_impl(new Impl())
 {
-    execengine (NULL);
-    delete m_llvm_module_passes;
-    delete m_llvm_func_passes;
-    delete m_builder;
-    module (NULL);
-    // DO NOT delete m_llvm_jitmm;  // just the dummy wrapper around the real MM
+    m_impl->debug (debuglevel);
 }
 
 
 
-void
-LLVM_Util::SetupLLVM ()
+LLVM_Util::~LLVM_Util ()
 {
-    OIIO::spin_lock lock (llvm_global_mutex);
-    if (setup_done)
-        return;
-    // Some global LLVM initialization for the first thread that
-    // gets here.
-
-#if OSL_LLVM_VERSION < 35
-    // enable it to be thread-safe
-    llvm::llvm_start_multithreaded ();
-#endif
-// new versions (>=3.5)don't need this anymore
-
-#if USE_MCJIT
-    llvm::InitializeAllTargets();
-    llvm::InitializeAllTargetInfos();
-    llvm::InitializeAllTargetMCs();
-    llvm::InitializeAllAsmPrinters();
-    llvm::InitializeAllAsmParsers();
-    llvm::InitializeAllDisassemblers();
-#else
-    llvm::InitializeNativeTarget();
-#endif
-
-    if (debug()) {
-        for (llvm::TargetRegistry::iterator t = llvm::TargetRegistry::begin();
-             t != llvm::TargetRegistry::end();  ++t) {
-            std::cout << "Target: '" << t->getName() << "' "
-                      << t->getShortDescription() << "\n";
-        }
-        std::cout << "\n";
-    }
-
-    setup_done = true;
 }
 
 
 
-llvm::Module *
-LLVM_Util::new_module (const char *id)
+void LLVM_Util::debug (int d)
 {
-    return new llvm::Module(id, context());
+    m_impl->debug (d);
 }
 
-
-
-llvm::Module *
-LLVM_Util::module_from_bitcode (const char *bitcode, size_t size,
-                                const std::string &name, std::string *err)
+int LLVM_Util::debug () const
 {
-    if (err)
-        err->clear();
+    return m_impl->debug();
+}
 
-#if OSL_LLVM_VERSION >= 36
-    llvm::MemoryBufferRef buf =
-        llvm::MemoryBufferRef(llvm::StringRef(bitcode, size), name);
-#else /* LLVM 3.5 or earlier */
-    llvm::MemoryBuffer* buf =
-        llvm::MemoryBuffer::getMemBuffer (llvm::StringRef(bitcode, size), name);
-#endif
 
-    // Load the LLVM bitcode and parse it into a Module
-    llvm::Module *m = NULL;
 
-#if USE_MCJIT
-    // FIXME!! Using MCJIT should not require unconditionally parsing
-    // the bitcode. But for now, when using getLazyBitcodeModule to
-    // lazily deserialize the bitcode, MCJIT is unable to find the
-    // called functions due to disagreement about whether a leading "_"
-    // is part of the symbol name.
-    llvm::ErrorOr<llvm::Module *> ModuleOrErr = llvm::parseBitcodeFile (buf, context());
-    if (std::error_code EC = ModuleOrErr.getError())
-        if (err)
-          *err = EC.message();
-    m = ModuleOrErr.get();
-#endif
-
-#if USE_OLD_JIT
-    // Create a lazily deserialized IR module
-    // This can only be done for old JIT
-# if OSL_LLVM_VERSION >= 35
-    m = llvm::getLazyBitcodeModule (buf, context()).get();
-# else
-    m = llvm::getLazyBitcodeModule (buf, context(), err);
-# endif
-    // don't delete buf, the module has taken ownership of it
-#endif /*USE_OLD_JIT*/
+void LLVM_Util::orc_jit (bool enable)
+{
+    m_impl->orc_jit (enable);
+}
 
-    // Debugging: print all functions in the module
-    // for (llvm::Module::iterator i = m->begin(); i != m->end(); ++i)
-    //     std::cout << "  found " << i->getName().data() << "\n";
-    return m;
+bool LLVM_Util::orc_jit () const
+{
+    return m_impl->orc_jit();
 }
 
 
 
-void
-LLVM_Util::new_builder (llvm::BasicBlock *block)
+llvm::LLVMContext &
+LLVM_Util::context () const
 {
-    end_builder();
-    if (! block)
-        block = new_basic_block ();
-    m_builder = new llvm::IRBuilder<> (block);
+    return m_impl->context();
 }
 
 
 
-void
-LLVM_Util::end_builder ()
+llvm::Module *
+LLVM_Util::module ()
 {
-    delete m_builder;
-    m_builder = NULL;
+    if (! impl()->module())
+        new_module ();
+    return impl()->module();
 }
 
 
 
-llvm::ExecutionEngine *
-LLVM_Util::make_jit_execengine (std::string *err)
-{
-    execengine (NULL);   // delete and clear any existing engine
-    if (err)
-        err->clear ();
-# if OSL_LLVM_VERSION >= 36
-    llvm::EngineBuilder engine_builder ((std::unique_ptr<llvm::Module>(module())));
-# else /* < 36: */
-    llvm::EngineBuilder engine_builder (module());
-# endif
+// void
+// LLVM_Util::module (llvm::Module *m)
+// {
+//     impl()->m_llvm_module.reset (m);
+// }
 
-    engine_builder.setEngineKind (llvm::EngineKind::JIT);
-    engine_builder.setErrorStr (err);
 
-#if USE_OLD_JIT
-    engine_builder.setJITMemoryManager (jitmm());
-    // N.B. createJIT will take ownership of the the JITMemoryManager!
-    engine_builder.setUseMCJIT (0);
-#else
-    // FIXME -- no memory manager for MCJIT yet
-    // engine_builder.setMemoryManager (jitmm());
-#endif /* USE_OLD_JIT */
 
-    engine_builder.setOptLevel (llvm::CodeGenOpt::Default);
+llvm::Module *
+LLVM_Util::new_module (string_view id)
+{
+    return m_impl->new_module (id);
+}
+
 
-    m_llvm_exec = engine_builder.create();
-    if (! m_llvm_exec)
-        return NULL;
 
-    // Force it to JIT as soon as we ask it for the code pointer,
-    // don't take any chances that it might JIT lazily, since we
-    // will be stealing the JIT code memory from under its nose and
-    // destroying the Module & ExecutionEngine.
-    m_llvm_exec->DisableLazyCompilation ();
-    return m_llvm_exec;
+llvm::Module *
+LLVM_Util::module_from_bitcode (string_view bitcode, string_view name,
+                                std::string *err)
+{
+    return m_impl->module_from_bitcode (bitcode, name, err);
 }
 
 
 
-void
-LLVM_Util::execengine (llvm::ExecutionEngine *exec)
+LLVM_Util::IRBuilder &
+LLVM_Util::builder ()
 {
-    delete m_llvm_exec;
-    m_llvm_exec = exec;
+    return m_impl->builder();
 }
 
 
 
 void *
-LLVM_Util::getPointerToFunction (llvm::Function *func)
+LLVM_Util::get_compiled_function (string_view name)
 {
-    DASSERT (func && "passed NULL to getPointerToFunction");
-    llvm::ExecutionEngine *exec = execengine();
-    if (USE_MCJIT)
-        exec->finalizeObject ();
-    void *f = exec->getPointerToFunction (func);
-    ASSERT (f && "could not getPointerToFunction");
-    return f;
+    return m_impl->get_compiled_function (name);
 }
 
 
@@ -500,8 +686,7 @@ LLVM_Util::getPointerToFunction (llvm::F
 void
 LLVM_Util::InstallLazyFunctionCreator (void* (*P)(const std::string &))
 {
-    llvm::ExecutionEngine *exec = execengine();
-    exec->InstallLazyFunctionCreator (P);
+    m_impl->InstallLazyFunctionCreator (P);
 }
 
 
@@ -509,62 +694,40 @@ LLVM_Util::InstallLazyFunctionCreator (v
 void
 LLVM_Util::setup_optimization_passes (int optlevel)
 {
-    ASSERT (m_llvm_module_passes == NULL && m_llvm_func_passes == NULL);
+    m_impl->setup_optimization_passes (optlevel);
+}
+
 
+
+void
+LLVM_Util::Impl::setup_optimization_passes (int optlevel)
+{
     // Construct the per-function passes and module-wide (interprocedural
     // optimization) passes.
     //
     // LLVM keeps changing names and call sequence. This part is easier to
     // understand if we explicitly break it into individual LLVM versions.
-#if OSL_LLVM_VERSION >= 36
-
-    m_llvm_func_passes = new llvm::legacy::FunctionPassManager(module());
-    llvm::legacy::FunctionPassManager &fpm (*m_llvm_func_passes);
-    fpm.add (new llvm::DataLayoutPass());
-
-    m_llvm_module_passes = new llvm::legacy::PassManager;
-    llvm::legacy::PassManager &mpm (*m_llvm_module_passes);
-    mpm.add (new llvm::DataLayoutPass());
-
-#elif OSL_LLVM_VERSION == 35
-
-    m_llvm_func_passes = new llvm::legacy::FunctionPassManager(module());
-    llvm::legacy::FunctionPassManager &fpm (*m_llvm_func_passes);
-    fpm.add (new llvm::DataLayoutPass(module()));
-
-    m_llvm_module_passes = new llvm::legacy::PassManager;
-    llvm::legacy::PassManager &mpm (*m_llvm_module_passes);
-    mpm.add (new llvm::DataLayoutPass(module()));
 
-#elif OSL_LLVM_VERSION == 34
+    m_llvm_func_passes.reset (new llvm::legacy::FunctionPassManager(module()));
+    // llvm::legacy::FunctionPassManager &fpm (*m_llvm_func_passes);
+//    fpm.add (new llvm::DataLayoutPass());
 
-    m_llvm_func_passes = new llvm::legacy::FunctionPassManager(module());
-    llvm::legacy::FunctionPassManager &fpm (*m_llvm_func_passes);
-    fpm.add (new llvm::DataLayout(module()));
-
-    m_llvm_module_passes = new llvm::legacy::PassManager;
+    m_llvm_module_passes.reset (new llvm::legacy::PassManager);
     llvm::legacy::PassManager &mpm (*m_llvm_module_passes);
-    mpm.add (new llvm::DataLayout(module()));
-
-#endif
+    // mpm.add (new llvm::DataLayoutPass());
 
     if (optlevel >= 1 && optlevel <= 3) {
-#if OSL_LLVM_VERSION <= 34
-        // For LLVM 3.0 and higher, llvm_optimize 1-3 means to use the
-        // same set of optimizations as clang -O1, -O2, -O3
+        // optimize level 1-3 means to use the same set of optimizations as
+        // clang -O1, -O2, -O3
         llvm::PassManagerBuilder builder;
         builder.OptLevel = optlevel;
         builder.Inliner = llvm::createFunctionInliningPass();
         // builder.DisableUnrollLoops = true;
-        builder.populateFunctionPassManager (fpm);
+        // builder.populateFunctionPassManager (fpm);
         builder.populateModulePassManager (mpm);
-#else
-        // FIXME -- should we have the equivalent for LLVM >= 35?
-#endif
-
     } else {
-        // Unknown choices for llvm_optimize: use the same basic
-        // set of passes that we always have.
+        // Unknown choices for llvm_optimize: use a basic set of passes that
+        // gets the low-hanging fruit for low optimization cost.
 
         // Always add verifier?
         mpm.add (llvm::createVerifierPass());
@@ -601,7 +764,15 @@ LLVM_Util::setup_optimization_passes (in
 void
 LLVM_Util::do_optimize ()
 {
-    m_llvm_module_passes->run (*module());
+    m_impl->do_optimize ();
+}
+
+
+
+void
+LLVM_Util::module_done ()
+{
+    m_impl->module_done ();
 }
 
 
@@ -674,57 +845,89 @@ LLVM_Util::internalize_module_functions
 
 
 llvm::Function *
-LLVM_Util::make_function (const std::string &name, bool fastcall,
+LLVM_Util::make_function (string_view name, bool fastcall,
                           llvm::Type *rettype,
                           llvm::Type *arg1,
                           llvm::Type *arg2,
                           llvm::Type *arg3,
                           llvm::Type *arg4)
 {
-    llvm::Function *func = llvm::cast<llvm::Function>(
-        module()->getOrInsertFunction (name, rettype,
-                                       arg1, arg2, arg3, arg4, NULL));
-    if (fastcall)
-        func->setCallingConv(llvm::CallingConv::Fast);
-    return func;
+    std::vector<llvm::Type*> args;
+    if (arg1) args.push_back (arg1);
+    if (arg2) args.push_back (arg2);
+    if (arg3) args.push_back (arg3);
+    if (arg4) args.push_back (arg4);
+    return make_function (name, fastcall, rettype, args);
 }
 
 
 
 llvm::Function *
-LLVM_Util::make_function (const std::string &name, bool fastcall,
+LLVM_Util::make_function (string_view name, bool fastcall,
                           llvm::Type *rettype,
-                          const std::vector<llvm::Type*> &params,
-                          bool varargs)
+                          array_view<llvm::Type*> params,
+                          HasVarArgs varargs)
 {
+    if (! module())
+        new_module ();
     llvm::FunctionType *functype = type_function (rettype, params, varargs);
-    llvm::Constant *c = module()->getOrInsertFunction (name, functype);
-    ASSERT (c && "getOrInsertFunction returned NULL");
-    ASSERT_MSG (llvm::isa<llvm::Function>(c),
-                "Declaration for %s is wrong, LLVM had to make a cast", name.c_str());
-    llvm::Function *func = llvm::cast<llvm::Function>(c);
+    llvm::Function *func = llvm::Function::Create (functype, llvm::Function::ExternalLinkage,
+                                                   SR(name), module());
+    // llvm::Constant *c = module()->getOrInsertFunction (SR(name), functype);
+    // ASSERT (c && "getOrInsertFunction returned NULL");
+    // ASSERT_MSG (llvm::isa<llvm::Function>(c),
+                // "Declaration for %s is wrong, LLVM had to make a cast", name.c_str());
+    // llvm::Function *func = llvm::cast<llvm::Function>(c);
     if (fastcall)
         func->setCallingConv(llvm::CallingConv::Fast);
+    current_function (func);
+    set_insert_point ();
     return func;
 }
 
 
 
+llvm::Function *
+LLVM_Util::declare_extern_function (string_view name, llvm::Type *rettype,
+                                    array_view<llvm::Type*> params,
+                                    HasVarArgs varargs)
+{
+    if (! module())
+        new_module ();
+    llvm::FunctionType *functype = type_function (rettype, params, varargs);
+    llvm::Function *func = llvm::Function::Create (functype, llvm::Function::ExternalLinkage,
+                                                   SR(name), module());
+    return func;
+}
+
+
+
+void
+LLVM_Util::current_function (llvm::Function *func)
+{
+    m_impl->current_function (func);
+}
+
+
+llvm::Function *
+LLVM_Util::current_function () const
+{
+    return m_impl->current_function();
+}
+
+
 llvm::Value *
 LLVM_Util::current_function_arg (int a)
 {
-    llvm::Function::arg_iterator arg_it = current_function()->arg_begin();
-    for (int i = 0;  i < a;  ++i)
-        ++arg_it;
-    return arg_it;
+    return m_impl->current_function_arg (a);
 }
 
 
 
 llvm::BasicBlock *
-LLVM_Util::new_basic_block (const std::string &name)
+LLVM_Util::new_basic_block (string_view name, bool insert)
 {
-    return llvm::BasicBlock::Create (context(), name, current_function());
+    return m_impl->new_basic_block (name, insert);
 }
 
 
@@ -732,10 +935,7 @@ LLVM_Util::new_basic_block (const std::s
 llvm::BasicBlock *
 LLVM_Util::push_function (llvm::BasicBlock *after)
 {
-    if (! after)
-        after = new_basic_block ();
-    m_return_block.push_back (after);
-    return after;
+    return m_impl->push_function (after);
 }
 
 
@@ -743,9 +943,7 @@ LLVM_Util::push_function (llvm::BasicBlo
 void
 LLVM_Util::pop_function ()
 {
-    ASSERT (! m_return_block.empty());
-    builder().SetInsertPoint (m_return_block.back());
-    m_return_block.pop_back ();
+    m_impl->pop_function ();
 }
 
 
@@ -753,8 +951,7 @@ LLVM_Util::pop_function ()
 llvm::BasicBlock *
 LLVM_Util::return_block () const
 {
-    ASSERT (! m_return_block.empty());
-    return m_return_block.back();
+    return m_impl->return_block ();
 }
 
 
@@ -762,8 +959,7 @@ LLVM_Util::return_block () const
 void 
 LLVM_Util::push_loop (llvm::BasicBlock *step, llvm::BasicBlock *after)
 {
-    m_loop_step_block.push_back (step);
-    m_loop_after_block.push_back (after);
+    m_impl->push_loop (step, after);
 }
 
 
@@ -771,9 +967,7 @@ LLVM_Util::push_loop (llvm::BasicBlock *
 void 
 LLVM_Util::pop_loop ()
 {
-    ASSERT (! m_loop_step_block.empty() && ! m_loop_after_block.empty());
-    m_loop_step_block.pop_back ();
-    m_loop_after_block.pop_back ();
+    m_impl->pop_loop ();
 }
 
 
@@ -781,8 +975,7 @@ LLVM_Util::pop_loop ()
 llvm::BasicBlock *
 LLVM_Util::loop_step_block () const
 {
-    ASSERT (! m_loop_step_block.empty());
-    return m_loop_step_block.back();
+    return m_impl->loop_step_block ();
 }
 
 
@@ -790,8 +983,7 @@ LLVM_Util::loop_step_block () const
 llvm::BasicBlock *
 LLVM_Util::loop_after_block () const
 {
-    ASSERT (! m_loop_after_block.empty());
-    return m_loop_after_block.back();
+    return m_impl->loop_after_block ();
 }
 
 
@@ -830,11 +1022,32 @@ LLVM_Util::type_union(const std::vector<
 
 
 
+llvm::Type *LLVM_Util::type_float() const {return m_impl->type_float(); }
+llvm::Type *LLVM_Util::type_int() const {return m_impl->type_int(); }
+llvm::Type *LLVM_Util::type_addrint() const {return m_impl->type_addrint(); }
+llvm::Type *LLVM_Util::type_bool() const {return m_impl->type_bool(); }
+llvm::Type *LLVM_Util::type_char() const {return m_impl->type_char(); }
+llvm::Type *LLVM_Util::type_longlong() const {return m_impl->type_longlong(); }
+llvm::Type *LLVM_Util::type_void() const {return m_impl->type_void(); }
+llvm::Type *LLVM_Util::type_triple() const {return m_impl->type_triple(); }
+llvm::Type *LLVM_Util::type_matrix() const {return m_impl->type_matrix(); }
+llvm::Type *LLVM_Util::type_typedesc() const {return m_impl->type_longlong(); }
+llvm::PointerType *LLVM_Util::type_void_ptr() const {return m_impl->type_void_ptr(); }
+llvm::PointerType *LLVM_Util::type_string() const { return m_impl->type_char_ptr(); }
+llvm::PointerType *LLVM_Util::type_ustring_ptr() const {return m_impl->type_ustring_ptr(); }
+llvm::PointerType *LLVM_Util::type_char_ptr() const {return m_impl->type_char_ptr(); }
+llvm::PointerType *LLVM_Util::type_int_ptr() const {return m_impl->type_int_ptr(); }
+llvm::PointerType *LLVM_Util::type_float_ptr() const {return m_impl->type_float_ptr(); }
+llvm::PointerType *LLVM_Util::type_triple_ptr() const {return m_impl->type_triple_ptr(); }
+llvm::PointerType *LLVM_Util::type_matrix_ptr() const {return m_impl->type_matrix_ptr(); }
+
+
+
 llvm::Type *
 LLVM_Util::type_struct (const std::vector<llvm::Type *> &types,
-                        const std::string &name)
+                        string_view name)
 {
-    return llvm::StructType::create(context(), types, name);
+    return llvm::StructType::create(context(), types, SR(name));
 }
 
 
@@ -857,18 +1070,18 @@ LLVM_Util::type_array (llvm::Type *type,
 
 llvm::FunctionType *
 LLVM_Util::type_function (llvm::Type *rettype,
-                          const std::vector<llvm::Type*> &params,
-                          bool varargs)
+                          array_view<llvm::Type*> params,
+                          HasVarArgs varargs)
 {
-    return llvm::FunctionType::get (rettype, params, varargs);
+    return llvm::FunctionType::get (rettype, AR(params), varargs==VarArgs);
 }
 
 
 
 llvm::PointerType *
 LLVM_Util::type_function_ptr (llvm::Type *rettype,
-                              const std::vector<llvm::Type*> &params,
-                              bool varargs)
+                              array_view<llvm::Type*> params,
+                              HasVarArgs varargs)
 {
     llvm::FunctionType *functype = type_function (rettype, params, varargs);
     return llvm::PointerType::getUnqual (functype);
@@ -1056,16 +1269,16 @@ LLVM_Util::offset_ptr (llvm::Value *ptr,
 
 
 llvm::Value *
-LLVM_Util::op_alloca (llvm::Type *llvmtype, int n, const std::string &name)
+LLVM_Util::op_alloca (llvm::Type *llvmtype, int n, string_view name)
 {
     llvm::ConstantInt* numalloc = (llvm::ConstantInt*)constant(n);
-    return builder().CreateAlloca (llvmtype, numalloc, name);
+    return builder().CreateAlloca (llvmtype, numalloc, SR(name));
 }
 
 
 
 llvm::Value *
-LLVM_Util::op_alloca (const TypeDesc &type, int n, const std::string &name)
+LLVM_Util::op_alloca (const TypeDesc &type, int n, string_view name)
 {
     return op_alloca (llvm_type(type.elementtype()), n*type.numelements(), name);
 }
@@ -1073,7 +1286,7 @@ LLVM_Util::op_alloca (const TypeDesc &ty
 
 
 llvm::Value *
-LLVM_Util::call_function (llvm::Value *func, llvm::Value **args, int nargs)
+LLVM_Util::call_function (llvm::Value *func, OIIO::array_view<llvm::Value *> args)
 {
     ASSERT (func);
 #if 0
@@ -1083,7 +1296,7 @@ LLVM_Util::call_function (llvm::Value *f
         llvm::outs() << "\t" << *(args[i]) << "\n";
 #endif
     //llvm_gen_debug_printf (std::string("start ") + std::string(name));
-    llvm::Value *r = builder().CreateCall (func, llvm::ArrayRef<llvm::Value *>(args, nargs));
+    llvm::Value *r = builder().CreateCall (func, AR(args));
     //llvm_gen_debug_printf (std::string(" end  ") + std::string(name));
     return r;
 }
@@ -1091,12 +1304,12 @@ LLVM_Util::call_function (llvm::Value *f
 
 
 llvm::Value *
-LLVM_Util::call_function (const char *name, llvm::Value **args, int nargs)
+LLVM_Util::call_function (string_view name, OIIO::array_view<llvm::Value *> args)
 {
-    llvm::Function *func = module()->getFunction (name);
+    llvm::Function *func = module()->getFunction (SR(name));
     if (! func)
         std::cerr << "Couldn't find function " << name << "\n";
-    return call_function (func, args, nargs);
+    return call_function (func, args);
 }
 
 
@@ -1132,6 +1345,8 @@ LLVM_Util::op_branch (llvm::Value *cond,
 void
 LLVM_Util::set_insert_point (llvm::BasicBlock *block)
 {
+    if (! block)
+        block = new_basic_block ();
     builder().SetInsertPoint (block);
 }
 
@@ -1167,8 +1382,7 @@ LLVM_Util::op_memset (llvm::Value *ptr,
     };
 
     llvm::Function* func = llvm::Intrinsic::getDeclaration (module(),
-        llvm::Intrinsic::memset,
-        llvm::ArrayRef<llvm::Type *>(types, sizeof(types)/sizeof(llvm::Type*)));
+        llvm::Intrinsic::memset, types);
 
     // NOTE(boulos): constant(0) would return an i32
     // version of 0, but we need the i8 version. If we make an
@@ -1178,8 +1392,9 @@ LLVM_Util::op_memset (llvm::Value *ptr,
                                                     llvm::APInt(8, val));
     // Non-volatile (allow optimizer to move it around as it wishes
     // and even remove it if it can prove it's useless)
-    builder().CreateCall5 (func, ptr, fill_val, len, constant(align),
-                           constant_bool(false));
+    llvm::Value *args[] = { ptr, fill_val, len, constant(align),
+                            constant_bool(false) };
+    builder().CreateCall (func, args);
 }
 
 
@@ -1196,13 +1411,13 @@ LLVM_Util::op_memcpy (llvm::Value *dst,
     };
 
     llvm::Function* func = llvm::Intrinsic::getDeclaration (module(),
-        llvm::Intrinsic::memcpy,
-        llvm::ArrayRef<llvm::Type *>(types, sizeof(types)/sizeof(llvm::Type*)));
+        llvm::Intrinsic::memcpy, types);
 
     // Non-volatile (allow optimizer to move it around as it wishes
     // and even remove it if it can prove it's useless)
-    builder().CreateCall5 (func, dst, src,
-                           constant(len), constant(align), constant_bool(false));
+    llvm::Value *args[] = { dst, src, constant(len), constant(align),
+                            constant_bool(false) };
+    builder().CreateCall (func, args);
 }
 
 
@@ -1242,7 +1457,7 @@ LLVM_Util::GEP (llvm::Value *ptr, int el
 llvm::Value *
 LLVM_Util::GEP (llvm::Value *ptr, int elem1, int elem2)
 {
-    return builder().CreateConstGEP2_32 (ptr, elem1, elem2);
+    return builder().CreateConstGEP2_32 (nullptr, ptr, elem1, elem2);
 }
 
 
@@ -1548,5 +1763,4 @@ LLVM_Util::func_name (llvm::Function *fu
 }
 
 
-}; // namespace pvt
 OSL_NAMESPACE_EXIT
diff -purN a/src/liboslexec/llvm_util_old.cpp b/src/liboslexec/llvm_util_old.cpp
--- a/src/liboslexec/llvm_util_old.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/src/liboslexec/llvm_util_old.cpp	2016-06-27 22:37:25.000000000 +0100
@@ -0,0 +1,1552 @@
+/*
+Copyright (c) 2009-2010 Sony Pictures Imageworks Inc., et al.
+All Rights Reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+* Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+* Neither the name of Sony Pictures Imageworks nor the names of its
+  contributors may be used to endorse or promote products derived from
+  this software without specific prior written permission.
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+#include <OpenImageIO/thread.h>
+#include <boost/thread/tss.hpp>   /* for thread_specific_ptr */
+
+#include "OSL/oslconfig.h"
+#include "OSL/llvm_util.h"
+
+#if OSL_LLVM_VERSION < 34
+#error "LLVM minimum version required for OSL is 3.4"
+#endif
+
+#if OSL_LLVM_VERSION >= 35 && OSL_CPLUSPLUS_VERSION < 11
+#error "LLVM >= 3.5 requires C++11 or newer"
+#endif
+
+// Use MCJIT for LLVM 3.6 and beyind, old JIT for earlier
+#define USE_MCJIT   (OSL_LLVM_VERSION >= 36)
+#define USE_OLD_JIT (OSL_LLVM_VERSION <  36)
+
+#include <llvm/IR/Constants.h>
+#include <llvm/IR/DerivedTypes.h>
+#include <llvm/IR/Instructions.h>
+#include <llvm/IR/Intrinsics.h>
+#include <llvm/IR/Module.h>
+#include <llvm/IR/LLVMContext.h>
+#include <llvm/IR/IRBuilder.h>
+#include <llvm/IR/DataLayout.h>
+#if OSL_LLVM_VERSION >= 35
+#  include <llvm/Linker/Linker.h>
+#  include <llvm/Support/FileSystem.h>
+#else
+#  include <llvm/Linker.h>
+#endif
+#include <llvm/Support/ErrorOr.h>
+#include <llvm/IR/LegacyPassManager.h>
+#include <llvm/Support/TargetRegistry.h>
+
+#include <llvm/Bitcode/ReaderWriter.h>
+#include <llvm/Support/ManagedStatic.h>
+#include <llvm/Support/MemoryBuffer.h>
+#include <llvm/ExecutionEngine/GenericValue.h>
+#if USE_MCJIT
+#  include <llvm/ExecutionEngine/MCJIT.h>
+#endif
+#if USE_OLD_JIT
+#  include <llvm/ExecutionEngine/JIT.h>
+#  include <llvm/ExecutionEngine/JITMemoryManager.h>
+#endif
+#include <llvm/Support/raw_ostream.h>
+#include <llvm/Support/TargetSelect.h>
+#include <llvm/Support/PrettyStackTrace.h>
+#if OSL_LLVM_VERSION >= 35
+#  include <llvm/IR/Verifier.h>
+#else
+#  include <llvm/Analysis/Verifier.h>
+#endif
+#include <llvm/Target/TargetOptions.h>
+#include <llvm/Transforms/Scalar.h>
+#include <llvm/Transforms/IPO.h>
+#include <llvm/Transforms/Utils/UnifyFunctionExitNodes.h>
+#include <llvm/Transforms/IPO/PassManagerBuilder.h>
+
+OSL_NAMESPACE_ENTER
+
+namespace pvt {
+
+#if USE_OLD_JIT
+using llvm::JITMemoryManager;
+// #else
+// typedef JITMemoryManager;
+#endif
+
+namespace {
+static OIIO::spin_mutex llvm_global_mutex;
+static bool setup_done = false;
+static boost::thread_specific_ptr<LLVM_Util::PerThreadInfo> perthread_infos;
+#if USE_OLD_JIT
+static std::vector<shared_ptr<JITMemoryManager> > jitmm_hold;
+#endif
+};
+
+
+
+
+// We hold certain things (LLVM context and custom JIT memory manager)
+// per thread and retained across LLVM_Util invocations.  We are
+// intentionally "leaking" them.
+struct LLVM_Util::PerThreadInfo {
+    PerThreadInfo () : llvm_context(NULL), llvm_jitmm(NULL) {}
+    ~PerThreadInfo () {
+        delete llvm_context;
+        // N.B. Do NOT delete the jitmm -- another thread may need the
+        // code! Don't worry, we stashed a pointer in jitmm_hold.
+    }
+    static void destroy (PerThreadInfo *threadinfo) { delete threadinfo; }
+    static PerThreadInfo *get () {
+        PerThreadInfo *p = perthread_infos.get ();
+        if (! p) {
+            p = new PerThreadInfo();
+            perthread_infos.reset (p);
+        }
+        return p;
+    }
+
+    llvm::LLVMContext *llvm_context;
+    llvm::JITMemoryManager *llvm_jitmm;
+};
+
+
+
+
+size_t
+LLVM_Util::total_jit_memory_held ()
+{
+    size_t jitmem = 0;
+    OIIO::spin_lock lock (llvm_global_mutex);
+#if USE_OLD_JIT
+    for (size_t i = 0;  i < jitmm_hold.size();  ++i) {
+        llvm::JITMemoryManager *mm = jitmm_hold[i].get();
+        if (mm)
+            jitmem += mm->GetDefaultCodeSlabSize() * mm->GetNumCodeSlabs()
+                    + mm->GetDefaultDataSlabSize() * mm->GetNumDataSlabs()
+                    + mm->GetDefaultStubSlabSize() * mm->GetNumStubSlabs();
+    }
+#endif
+    return jitmem;
+}
+
+
+
+#if USE_OLD_JIT
+
+/// OSL_Dummy_JITMemoryManager - Create a shell that passes on requests
+/// to a real JITMemoryManager underneath, but can be retained after the
+/// dummy is destroyed.  Also, we don't pass along any deallocations.
+class OSL_Dummy_JITMemoryManager : public llvm::JITMemoryManager {
+protected:
+    llvm::JITMemoryManager *mm;  // the real one
+public:
+    OSL_Dummy_JITMemoryManager(llvm::JITMemoryManager *realmm) : mm(realmm) { HasGOT = realmm->isManagingGOT(); }
+    virtual ~OSL_Dummy_JITMemoryManager() {}
+    virtual void setMemoryWritable() { mm->setMemoryWritable(); }
+    virtual void setMemoryExecutable() { mm->setMemoryExecutable(); }
+    virtual void setPoisonMemory(bool poison) { mm->setPoisonMemory(poison); }
+    virtual void AllocateGOT() { ASSERT(HasGOT == false); ASSERT(HasGOT == mm->isManagingGOT()); mm->AllocateGOT(); HasGOT = true; ASSERT(HasGOT == mm->isManagingGOT()); }
+    virtual uint8_t *getGOTBase() const { return mm->getGOTBase(); }
+    virtual uint8_t *startFunctionBody(const llvm::Function *F,
+                                       uintptr_t &ActualSize) {
+        return mm->startFunctionBody (F, ActualSize);
+    }
+    virtual uint8_t *allocateStub(const llvm::GlobalValue* F, unsigned StubSize,
+                                  unsigned Alignment) {
+        return mm->allocateStub (F, StubSize, Alignment);
+    }
+    virtual void endFunctionBody(const llvm::Function *F,
+                                 uint8_t *FunctionStart, uint8_t *FunctionEnd) {
+        mm->endFunctionBody (F, FunctionStart, FunctionEnd);
+    }
+    virtual uint8_t *allocateSpace(intptr_t Size, unsigned Alignment) {
+        return mm->allocateSpace (Size, Alignment);
+    }
+    virtual uint8_t *allocateGlobal(uintptr_t Size, unsigned Alignment) {
+        return mm->allocateGlobal (Size, Alignment);
+    }
+    virtual void deallocateFunctionBody(void *Body) {
+        // DON'T DEALLOCATE mm->deallocateFunctionBody (Body);
+    }
+    virtual bool CheckInvariants(std::string &s) {
+        return mm->CheckInvariants(s);
+    }
+    virtual size_t GetDefaultCodeSlabSize() {
+        return mm->GetDefaultCodeSlabSize();
+    }
+    virtual size_t GetDefaultDataSlabSize() {
+        return mm->GetDefaultDataSlabSize();
+    }
+    virtual size_t GetDefaultStubSlabSize() {
+        return mm->GetDefaultStubSlabSize();
+    }
+    virtual unsigned GetNumCodeSlabs() { return mm->GetNumCodeSlabs(); }
+    virtual unsigned GetNumDataSlabs() { return mm->GetNumDataSlabs(); }
+    virtual unsigned GetNumStubSlabs() { return mm->GetNumStubSlabs(); }
+
+    virtual void *getPointerToNamedFunction(const std::string &Name,
+                                            bool AbortOnFailure = true) {
+        return mm->getPointerToNamedFunction (Name, AbortOnFailure);
+    }
+    virtual uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,
+                             unsigned SectionID, llvm::StringRef SectionName) {
+        return mm->allocateCodeSection(Size, Alignment, SectionID, SectionName);
+    }
+    virtual uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,
+                             unsigned SectionID, llvm::StringRef SectionName,
+                             bool IsReadOnly) {
+        return mm->allocateDataSection(Size, Alignment, SectionID,
+                                       SectionName, IsReadOnly);
+    }
+    virtual void registerEHFrames(uint8_t *Addr, uint64_t LoadAddr, size_t Size) {
+        mm->registerEHFrames (Addr, LoadAddr, Size);
+    }
+    virtual void deregisterEHFrames(uint8_t *Addr, uint64_t LoadAddr, size_t Size) {
+        mm->deregisterEHFrames(Addr, LoadAddr, Size);
+    }
+    virtual uint64_t getSymbolAddress(const std::string &Name) {
+        return mm->getSymbolAddress (Name);
+    }
+    virtual void notifyObjectLoaded(llvm::ExecutionEngine *EE, const llvm::ObjectImage *oi) {
+        mm->notifyObjectLoaded (EE, oi);
+    }
+    virtual bool finalizeMemory(std::string *ErrMsg = 0) {
+        return mm->finalizeMemory (ErrMsg);
+    }
+};
+
+#endif
+
+
+
+
+LLVM_Util::LLVM_Util (int debuglevel)
+    : m_debug(debuglevel), m_thread(NULL),
+      m_llvm_context(NULL), m_llvm_module(NULL),
+      m_builder(NULL), m_llvm_jitmm(NULL),
+      m_current_function(NULL),
+      m_llvm_module_passes(NULL), m_llvm_func_passes(NULL),
+      m_llvm_exec(NULL)
+{
+    SetupLLVM ();
+    m_thread = PerThreadInfo::get();
+    ASSERT (m_thread);
+
+    {
+        OIIO::spin_lock lock (llvm_global_mutex);
+        if (! m_thread->llvm_context)
+            m_thread->llvm_context = new llvm::LLVMContext();
+
+#if USE_OLD_JIT
+        if (! m_thread->llvm_jitmm) {
+            m_thread->llvm_jitmm = llvm::JITMemoryManager::CreateDefaultMemManager();
+            ASSERT (m_thread->llvm_jitmm);
+            jitmm_hold.push_back (shared_ptr<llvm::JITMemoryManager>(m_thread->llvm_jitmm));
+        }
+        m_llvm_jitmm = new OSL_Dummy_JITMemoryManager(m_thread->llvm_jitmm);
+#endif
+    }
+
+    m_llvm_context = m_thread->llvm_context;
+
+    // Set up aliases for types we use over and over
+    m_llvm_type_float = (llvm::Type *) llvm::Type::getFloatTy (*m_llvm_context);
+    m_llvm_type_int = (llvm::Type *) llvm::Type::getInt32Ty (*m_llvm_context);
+    if (sizeof(char *) == 4)
+        m_llvm_type_addrint = (llvm::Type *) llvm::Type::getInt32Ty (*m_llvm_context);
+    else
+        m_llvm_type_addrint = (llvm::Type *) llvm::Type::getInt64Ty (*m_llvm_context);
+    m_llvm_type_int_ptr = (llvm::PointerType *) llvm::Type::getInt32PtrTy (*m_llvm_context);
+    m_llvm_type_bool = (llvm::Type *) llvm::Type::getInt1Ty (*m_llvm_context);
+    m_llvm_type_char = (llvm::Type *) llvm::Type::getInt8Ty (*m_llvm_context);
+    m_llvm_type_longlong = (llvm::Type *) llvm::Type::getInt64Ty (*m_llvm_context);
+    m_llvm_type_void = (llvm::Type *) llvm::Type::getVoidTy (*m_llvm_context);
+    m_llvm_type_char_ptr = (llvm::PointerType *) llvm::Type::getInt8PtrTy (*m_llvm_context);
+    m_llvm_type_float_ptr = (llvm::PointerType *) llvm::Type::getFloatPtrTy (*m_llvm_context);
+    m_llvm_type_ustring_ptr = (llvm::PointerType *) llvm::PointerType::get (m_llvm_type_char_ptr, 0);
+    m_llvm_type_void_ptr = m_llvm_type_char_ptr;
+
+    // A triple is a struct composed of 3 floats
+    std::vector<llvm::Type*> triplefields(3, m_llvm_type_float);
+    m_llvm_type_triple = type_struct (triplefields, "Vec3");
+    m_llvm_type_triple_ptr = (llvm::PointerType *) llvm::PointerType::get (m_llvm_type_triple, 0);
+
+    // A matrix is a struct composed 16 floats
+    std::vector<llvm::Type*> matrixfields(16, m_llvm_type_float);
+    m_llvm_type_matrix = type_struct (matrixfields, "Matrix4");
+    m_llvm_type_matrix_ptr = (llvm::PointerType *) llvm::PointerType::get (m_llvm_type_matrix, 0);
+}
+
+
+
+LLVM_Util::~LLVM_Util ()
+{
+    execengine (NULL);
+    delete m_llvm_module_passes;
+    delete m_llvm_func_passes;
+    delete m_builder;
+    module (NULL);
+    // DO NOT delete m_llvm_jitmm;  // just the dummy wrapper around the real MM
+}
+
+
+
+void
+LLVM_Util::SetupLLVM ()
+{
+    OIIO::spin_lock lock (llvm_global_mutex);
+    if (setup_done)
+        return;
+    // Some global LLVM initialization for the first thread that
+    // gets here.
+
+#if OSL_LLVM_VERSION < 35
+    // enable it to be thread-safe
+    llvm::llvm_start_multithreaded ();
+#endif
+// new versions (>=3.5)don't need this anymore
+
+#if USE_MCJIT
+    llvm::InitializeAllTargets();
+    llvm::InitializeAllTargetInfos();
+    llvm::InitializeAllTargetMCs();
+    llvm::InitializeAllAsmPrinters();
+    llvm::InitializeAllAsmParsers();
+    llvm::InitializeAllDisassemblers();
+#else
+    llvm::InitializeNativeTarget();
+#endif
+
+    if (debug()) {
+        for (llvm::TargetRegistry::iterator t = llvm::TargetRegistry::begin();
+             t != llvm::TargetRegistry::end();  ++t) {
+            std::cout << "Target: '" << t->getName() << "' "
+                      << t->getShortDescription() << "\n";
+        }
+        std::cout << "\n";
+    }
+
+    setup_done = true;
+}
+
+
+
+llvm::Module *
+LLVM_Util::new_module (const char *id)
+{
+    return new llvm::Module(id, context());
+}
+
+
+
+llvm::Module *
+LLVM_Util::module_from_bitcode (const char *bitcode, size_t size,
+                                const std::string &name, std::string *err)
+{
+    if (err)
+        err->clear();
+
+#if OSL_LLVM_VERSION >= 36
+    llvm::MemoryBufferRef buf =
+        llvm::MemoryBufferRef(llvm::StringRef(bitcode, size), name);
+#else /* LLVM 3.5 or earlier */
+    llvm::MemoryBuffer* buf =
+        llvm::MemoryBuffer::getMemBuffer (llvm::StringRef(bitcode, size), name);
+#endif
+
+    // Load the LLVM bitcode and parse it into a Module
+    llvm::Module *m = NULL;
+
+#if USE_MCJIT
+    // FIXME!! Using MCJIT should not require unconditionally parsing
+    // the bitcode. But for now, when using getLazyBitcodeModule to
+    // lazily deserialize the bitcode, MCJIT is unable to find the
+    // called functions due to disagreement about whether a leading "_"
+    // is part of the symbol name.
+    llvm::ErrorOr<llvm::Module *> ModuleOrErr = llvm::parseBitcodeFile (buf, context());
+    if (std::error_code EC = ModuleOrErr.getError())
+        if (err)
+          *err = EC.message();
+    m = ModuleOrErr.get();
+#endif
+
+#if USE_OLD_JIT
+    // Create a lazily deserialized IR module
+    // This can only be done for old JIT
+# if OSL_LLVM_VERSION >= 35
+    m = llvm::getLazyBitcodeModule (buf, context()).get();
+# else
+    m = llvm::getLazyBitcodeModule (buf, context(), err);
+# endif
+    // don't delete buf, the module has taken ownership of it
+#endif /*USE_OLD_JIT*/
+
+    // Debugging: print all functions in the module
+    // for (llvm::Module::iterator i = m->begin(); i != m->end(); ++i)
+    //     std::cout << "  found " << i->getName().data() << "\n";
+    return m;
+}
+
+
+
+void
+LLVM_Util::new_builder (llvm::BasicBlock *block)
+{
+    end_builder();
+    if (! block)
+        block = new_basic_block ();
+    m_builder = new llvm::IRBuilder<> (block);
+}
+
+
+
+void
+LLVM_Util::end_builder ()
+{
+    delete m_builder;
+    m_builder = NULL;
+}
+
+
+
+llvm::ExecutionEngine *
+LLVM_Util::make_jit_execengine (std::string *err)
+{
+    execengine (NULL);   // delete and clear any existing engine
+    if (err)
+        err->clear ();
+# if OSL_LLVM_VERSION >= 36
+    llvm::EngineBuilder engine_builder ((std::unique_ptr<llvm::Module>(module())));
+# else /* < 36: */
+    llvm::EngineBuilder engine_builder (module());
+# endif
+
+    engine_builder.setEngineKind (llvm::EngineKind::JIT);
+    engine_builder.setErrorStr (err);
+
+#if USE_OLD_JIT
+    engine_builder.setJITMemoryManager (jitmm());
+    // N.B. createJIT will take ownership of the the JITMemoryManager!
+    engine_builder.setUseMCJIT (0);
+#else
+    // FIXME -- no memory manager for MCJIT yet
+    // engine_builder.setMemoryManager (jitmm());
+#endif /* USE_OLD_JIT */
+
+    engine_builder.setOptLevel (llvm::CodeGenOpt::Default);
+
+    m_llvm_exec = engine_builder.create();
+    if (! m_llvm_exec)
+        return NULL;
+
+    // Force it to JIT as soon as we ask it for the code pointer,
+    // don't take any chances that it might JIT lazily, since we
+    // will be stealing the JIT code memory from under its nose and
+    // destroying the Module & ExecutionEngine.
+    m_llvm_exec->DisableLazyCompilation ();
+    return m_llvm_exec;
+}
+
+
+
+void
+LLVM_Util::execengine (llvm::ExecutionEngine *exec)
+{
+    delete m_llvm_exec;
+    m_llvm_exec = exec;
+}
+
+
+
+void *
+LLVM_Util::getPointerToFunction (llvm::Function *func)
+{
+    DASSERT (func && "passed NULL to getPointerToFunction");
+    llvm::ExecutionEngine *exec = execengine();
+    if (USE_MCJIT)
+        exec->finalizeObject ();
+    void *f = exec->getPointerToFunction (func);
+    ASSERT (f && "could not getPointerToFunction");
+    return f;
+}
+
+
+
+void
+LLVM_Util::InstallLazyFunctionCreator (void* (*P)(const std::string &))
+{
+    llvm::ExecutionEngine *exec = execengine();
+    exec->InstallLazyFunctionCreator (P);
+}
+
+
+
+void
+LLVM_Util::setup_optimization_passes (int optlevel)
+{
+    ASSERT (m_llvm_module_passes == NULL && m_llvm_func_passes == NULL);
+
+    // Construct the per-function passes and module-wide (interprocedural
+    // optimization) passes.
+    //
+    // LLVM keeps changing names and call sequence. This part is easier to
+    // understand if we explicitly break it into individual LLVM versions.
+#if OSL_LLVM_VERSION >= 36
+
+    m_llvm_func_passes = new llvm::legacy::FunctionPassManager(module());
+    llvm::legacy::FunctionPassManager &fpm (*m_llvm_func_passes);
+    fpm.add (new llvm::DataLayoutPass());
+
+    m_llvm_module_passes = new llvm::legacy::PassManager;
+    llvm::legacy::PassManager &mpm (*m_llvm_module_passes);
+    mpm.add (new llvm::DataLayoutPass());
+
+#elif OSL_LLVM_VERSION == 35
+
+    m_llvm_func_passes = new llvm::legacy::FunctionPassManager(module());
+    llvm::legacy::FunctionPassManager &fpm (*m_llvm_func_passes);
+    fpm.add (new llvm::DataLayoutPass(module()));
+
+    m_llvm_module_passes = new llvm::legacy::PassManager;
+    llvm::legacy::PassManager &mpm (*m_llvm_module_passes);
+    mpm.add (new llvm::DataLayoutPass(module()));
+
+#elif OSL_LLVM_VERSION == 34
+
+    m_llvm_func_passes = new llvm::legacy::FunctionPassManager(module());
+    llvm::legacy::FunctionPassManager &fpm (*m_llvm_func_passes);
+    fpm.add (new llvm::DataLayout(module()));
+
+    m_llvm_module_passes = new llvm::legacy::PassManager;
+    llvm::legacy::PassManager &mpm (*m_llvm_module_passes);
+    mpm.add (new llvm::DataLayout(module()));
+
+#endif
+
+    if (optlevel >= 1 && optlevel <= 3) {
+#if OSL_LLVM_VERSION <= 34
+        // For LLVM 3.0 and higher, llvm_optimize 1-3 means to use the
+        // same set of optimizations as clang -O1, -O2, -O3
+        llvm::PassManagerBuilder builder;
+        builder.OptLevel = optlevel;
+        builder.Inliner = llvm::createFunctionInliningPass();
+        // builder.DisableUnrollLoops = true;
+        builder.populateFunctionPassManager (fpm);
+        builder.populateModulePassManager (mpm);
+#else
+        // FIXME -- should we have the equivalent for LLVM >= 35?
+#endif
+
+    } else {
+        // Unknown choices for llvm_optimize: use the same basic
+        // set of passes that we always have.
+
+        // Always add verifier?
+        mpm.add (llvm::createVerifierPass());
+        // Simplify the call graph if possible (deleting unreachable blocks, etc.)
+        mpm.add (llvm::createCFGSimplificationPass());
+        // Change memory references to registers
+        //  mpm.add (llvm::createPromoteMemoryToRegisterPass());
+        mpm.add (llvm::createScalarReplAggregatesPass());
+        // Combine instructions where possible -- peephole opts & bit-twiddling
+        mpm.add (llvm::createInstructionCombiningPass());
+        // Inline small functions
+        mpm.add (llvm::createFunctionInliningPass());  // 250?
+        // Eliminate early returns
+        mpm.add (llvm::createUnifyFunctionExitNodesPass());
+        // resassociate exprssions (a = x + (3 + y) -> a = x + y + 3)
+        mpm.add (llvm::createReassociatePass());
+        // Eliminate common sub-expressions
+        mpm.add (llvm::createGVNPass());
+        // Constant propagation with SCCP
+        mpm.add (llvm::createSCCPPass());
+        // More dead code elimination
+        mpm.add (llvm::createAggressiveDCEPass());
+        // Combine instructions where possible -- peephole opts & bit-twiddling
+        mpm.add (llvm::createInstructionCombiningPass());
+        // Simplify the call graph if possible (deleting unreachable blocks, etc.)
+        mpm.add (llvm::createCFGSimplificationPass());
+        // Try to make stuff into registers one last time.
+        mpm.add (llvm::createPromoteMemoryToRegisterPass());
+    }
+}
+
+
+
+void
+LLVM_Util::do_optimize ()
+{
+    m_llvm_module_passes->run (*module());
+}
+
+
+
+void
+LLVM_Util::internalize_module_functions (const std::string &prefix,
+                                         const std::vector<std::string> &exceptions,
+                                         const std::vector<std::string> &moreexceptions)
+{
+    for (llvm::Module::iterator iter = module()->begin(); iter != module()->end(); iter++) {
+        llvm::Function *sym = (llvm::Function *)(iter);
+        std::string symname = sym->getName();
+        if (prefix.size() && ! OIIO::Strutil::starts_with(symname, prefix))
+            continue;
+        bool needed = false;
+        for (size_t i = 0, e = exceptions.size(); i < e; ++i)
+            if (sym->getName() == exceptions[i]) {
+                needed = true;
+                // std::cout << "    necessary LLVM module function "
+                //           << sym->getName().str() << "\n";
+                break;
+            }
+        for (size_t i = 0, e = moreexceptions.size(); i < e; ++i)
+            if (sym->getName() == moreexceptions[i]) {
+                needed = true;
+                // std::cout << "    necessary LLVM module function "
+                //           << sym->getName().str() << "\n";
+                break;
+            }
+        if (!needed) {
+            llvm::GlobalValue::LinkageTypes linkage = sym->getLinkage();
+            // std::cout << "    unnecessary LLVM module function "
+            //           << sym->getName().str() << " linkage " << int(linkage) << "\n";
+            if (linkage == llvm::GlobalValue::ExternalLinkage)
+                sym->setLinkage (llvm::GlobalValue::LinkOnceODRLinkage);
+            // ExternalLinkage means it's potentially externally callable,
+            // and so will definitely have code generated.
+            // LinkOnceODRLinkage keeps one copy so it can be inlined or
+            // called internally to the module, but allows it to be
+            // discarded otherwise.
+        }
+    }
+#if 0
+    // I don't think we need to worry about linkage of global symbols, but
+    // here is an example of how to iterate over the globals anyway.
+    for (llvm::Module::global_iterator iter = module()->global_begin(); iter != module()->global_end(); iter++) {
+        llvm::GlobalValue *sym = llvm::dyn_cast<llvm::GlobalValue>(iter);
+        if (!sym)
+            continue;
+        std::string symname = sym->getName();
+        if (prefix.size() && ! OIIO::Strutil::starts_with(symname, prefix))
+            continue;
+        bool needed = false;
+        for (size_t i = 0, e = exceptions.size(); i < e; ++i)
+            if (sym->getName() == exceptions[i]) {
+                needed = true;
+                break;
+            }
+        if (! needed) {
+            llvm::GlobalValue::LinkageTypes linkage = sym->getLinkage();
+            // std::cout << "    unnecessary LLVM global " << sym->getName().str()
+            //           << " linkage " << int(linkage) << "\n";
+            if (linkage == llvm::GlobalValue::ExternalLinkage)
+                f->setLinkage (llvm::GlobalValue::LinkOnceODRLinkage);
+        }
+    }
+#endif
+}
+
+
+
+llvm::Function *
+LLVM_Util::make_function (const std::string &name, bool fastcall,
+                          llvm::Type *rettype,
+                          llvm::Type *arg1,
+                          llvm::Type *arg2,
+                          llvm::Type *arg3,
+                          llvm::Type *arg4)
+{
+    llvm::Function *func = llvm::cast<llvm::Function>(
+        module()->getOrInsertFunction (name, rettype,
+                                       arg1, arg2, arg3, arg4, NULL));
+    if (fastcall)
+        func->setCallingConv(llvm::CallingConv::Fast);
+    return func;
+}
+
+
+
+llvm::Function *
+LLVM_Util::make_function (const std::string &name, bool fastcall,
+                          llvm::Type *rettype,
+                          const std::vector<llvm::Type*> &params,
+                          bool varargs)
+{
+    llvm::FunctionType *functype = type_function (rettype, params, varargs);
+    llvm::Constant *c = module()->getOrInsertFunction (name, functype);
+    ASSERT (c && "getOrInsertFunction returned NULL");
+    ASSERT_MSG (llvm::isa<llvm::Function>(c),
+                "Declaration for %s is wrong, LLVM had to make a cast", name.c_str());
+    llvm::Function *func = llvm::cast<llvm::Function>(c);
+    if (fastcall)
+        func->setCallingConv(llvm::CallingConv::Fast);
+    return func;
+}
+
+
+
+llvm::Value *
+LLVM_Util::current_function_arg (int a)
+{
+    llvm::Function::arg_iterator arg_it = current_function()->arg_begin();
+    for (int i = 0;  i < a;  ++i)
+        ++arg_it;
+    return arg_it;
+}
+
+
+
+llvm::BasicBlock *
+LLVM_Util::new_basic_block (const std::string &name)
+{
+    return llvm::BasicBlock::Create (context(), name, current_function());
+}
+
+
+
+llvm::BasicBlock *
+LLVM_Util::push_function (llvm::BasicBlock *after)
+{
+    if (! after)
+        after = new_basic_block ();
+    m_return_block.push_back (after);
+    return after;
+}
+
+
+
+void
+LLVM_Util::pop_function ()
+{
+    ASSERT (! m_return_block.empty());
+    builder().SetInsertPoint (m_return_block.back());
+    m_return_block.pop_back ();
+}
+
+
+
+llvm::BasicBlock *
+LLVM_Util::return_block () const
+{
+    ASSERT (! m_return_block.empty());
+    return m_return_block.back();
+}
+
+
+
+void 
+LLVM_Util::push_loop (llvm::BasicBlock *step, llvm::BasicBlock *after)
+{
+    m_loop_step_block.push_back (step);
+    m_loop_after_block.push_back (after);
+}
+
+
+
+void 
+LLVM_Util::pop_loop ()
+{
+    ASSERT (! m_loop_step_block.empty() && ! m_loop_after_block.empty());
+    m_loop_step_block.pop_back ();
+    m_loop_after_block.pop_back ();
+}
+
+
+
+llvm::BasicBlock *
+LLVM_Util::loop_step_block () const
+{
+    ASSERT (! m_loop_step_block.empty());
+    return m_loop_step_block.back();
+}
+
+
+
+llvm::BasicBlock *
+LLVM_Util::loop_after_block () const
+{
+    ASSERT (! m_loop_after_block.empty());
+    return m_loop_after_block.back();
+}
+
+
+
+
+llvm::Type *
+LLVM_Util::type_union(const std::vector<llvm::Type *> &types)
+{
+    llvm::DataLayout target(module());
+    size_t max_size = 0;
+    size_t max_align = 1;
+    for (size_t i = 0; i < types.size(); ++i) {
+        size_t size = target.getTypeStoreSize(types[i]);
+        size_t align = target.getABITypeAlignment(types[i]);
+        max_size  = size  > max_size  ? size  : max_size;
+        max_align = align > max_align ? align : max_align;
+    }
+    size_t padding = (max_size % max_align) ? max_align - (max_size % max_align) : 0;
+    size_t union_size = max_size + padding;
+
+    llvm::Type * base_type = NULL;
+    // to ensure the alignment when included in a struct use
+    // an appropiate type for the array
+    if (max_align == sizeof(void*))
+        base_type = type_void_ptr();
+    else if (max_align == 4)
+        base_type = (llvm::Type *) llvm::Type::getInt32Ty (context());
+    else if (max_align == 2)
+        base_type = (llvm::Type *) llvm::Type::getInt16Ty (context());
+    else
+        base_type = (llvm::Type *) llvm::Type::getInt8Ty (context());
+
+    size_t array_len = union_size / target.getTypeStoreSize(base_type);
+    return (llvm::Type *) llvm::ArrayType::get (base_type, array_len);
+}
+
+
+
+llvm::Type *
+LLVM_Util::type_struct (const std::vector<llvm::Type *> &types,
+                        const std::string &name)
+{
+    return llvm::StructType::create(context(), types, name);
+}
+
+
+
+llvm::Type *
+LLVM_Util::type_ptr (llvm::Type *type)
+{
+    return llvm::PointerType::get (type, 0);
+}
+
+
+
+llvm::Type *
+LLVM_Util::type_array (llvm::Type *type, int n)
+{
+    return llvm::ArrayType::get (type, n);
+}
+
+
+
+llvm::FunctionType *
+LLVM_Util::type_function (llvm::Type *rettype,
+                          const std::vector<llvm::Type*> &params,
+                          bool varargs)
+{
+    return llvm::FunctionType::get (rettype, params, varargs);
+}
+
+
+
+llvm::PointerType *
+LLVM_Util::type_function_ptr (llvm::Type *rettype,
+                              const std::vector<llvm::Type*> &params,
+                              bool varargs)
+{
+    llvm::FunctionType *functype = type_function (rettype, params, varargs);
+    return llvm::PointerType::getUnqual (functype);
+}
+
+
+
+std::string
+LLVM_Util::llvm_typename (llvm::Type *type) const
+{
+    std::string s;
+    llvm::raw_string_ostream stream (s);
+    stream << (*type);
+    return stream.str();
+}
+
+
+
+llvm::Type *
+LLVM_Util::llvm_typeof (llvm::Value *val) const
+{
+    return val->getType();
+}
+
+
+
+std::string
+LLVM_Util::llvm_typenameof (llvm::Value *val) const
+{
+    return llvm_typename (llvm_typeof (val));
+}
+
+
+
+llvm::Value *
+LLVM_Util::constant (float f)
+{
+    return llvm::ConstantFP::get (context(), llvm::APFloat(f));
+}
+
+
+
+llvm::Value *
+LLVM_Util::constant (int i)
+{
+    return llvm::ConstantInt::get (context(), llvm::APInt(32,i));
+}
+
+
+
+llvm::Value *
+LLVM_Util::constant (size_t i)
+{
+    int bits = sizeof(size_t)*8;
+    return llvm::ConstantInt::get (context(), llvm::APInt(bits,i));
+}
+
+
+
+llvm::Value *
+LLVM_Util::constant_bool (bool i)
+{
+    return llvm::ConstantInt::get (context(), llvm::APInt(1,i));
+}
+
+
+
+llvm::Value *
+LLVM_Util::constant_ptr (void *p, llvm::PointerType *type)
+{
+    if (! type)
+        type = type_void_ptr();
+    return builder().CreateIntToPtr (constant (size_t (p)), type, "const pointer");
+}
+
+
+
+llvm::Value *
+LLVM_Util::constant (ustring s)
+{
+    // Create a const size_t with the ustring contents
+    size_t bits = sizeof(size_t)*8;
+    llvm::Value *str = llvm::ConstantInt::get (context(),
+                               llvm::APInt(bits,size_t(s.c_str()), true));
+    // Then cast the int to a char*.
+    return builder().CreateIntToPtr (str, type_string(), "ustring constant");
+}
+
+
+
+llvm::Value *
+LLVM_Util::constant (const TypeDesc &type)
+{
+    long long *i = (long long *)&type;
+    return llvm::ConstantInt::get (context(), llvm::APInt(64,*i));
+}
+
+
+
+llvm::Value *
+LLVM_Util::void_ptr_null ()
+{
+    return llvm::ConstantPointerNull::get (type_void_ptr());
+}
+
+
+
+llvm::Value *
+LLVM_Util::ptr_to_cast (llvm::Value* val, llvm::Type *type)
+{
+    return builder().CreatePointerCast(val,llvm::PointerType::get(type, 0));
+}
+
+
+
+llvm::Value *
+LLVM_Util::ptr_cast (llvm::Value* val, llvm::Type *type)
+{
+    return builder().CreatePointerCast(val,type);
+}
+
+
+
+llvm::Value *
+LLVM_Util::ptr_cast (llvm::Value* val, const TypeDesc &type)
+{
+    return ptr_cast (val, llvm::PointerType::get (llvm_type(type), 0));
+}
+
+
+
+llvm::Value *
+LLVM_Util::void_ptr (llvm::Value* val)
+{
+    return builder().CreatePointerCast(val,type_void_ptr());
+}
+
+
+
+
+llvm::Type *
+LLVM_Util::llvm_type (const TypeDesc &typedesc)
+{
+    TypeDesc t = typedesc.elementtype();
+    llvm::Type *lt = NULL;
+    if (t == TypeDesc::FLOAT)
+        lt = type_float();
+    else if (t == TypeDesc::INT)
+        lt = type_int();
+    else if (t == TypeDesc::STRING)
+        lt = type_string();
+    else if (t.aggregate == TypeDesc::VEC3)
+        lt = type_triple();
+    else if (t.aggregate == TypeDesc::MATRIX44)
+        lt = type_matrix();
+    else if (t == TypeDesc::NONE)
+        lt = type_void();
+    else if (t == TypeDesc::UINT8)
+        lt = type_char();
+    else if (t == TypeDesc::PTR)
+        lt = type_void_ptr();
+    else {
+        std::cerr << "Bad llvm_type(" << typedesc << ")\n";
+        ASSERT (0 && "not handling this type yet");
+    }
+    if (typedesc.arraylen)
+        lt = llvm::ArrayType::get (lt, typedesc.arraylen);
+    DASSERT (lt);
+    return lt;
+}
+
+
+
+llvm::Value *
+LLVM_Util::offset_ptr (llvm::Value *ptr, int offset, llvm::Type *ptrtype)
+{
+    llvm::Value *i = builder().CreatePtrToInt (ptr, type_addrint());
+    i = builder().CreateAdd (i, constant ((size_t)offset));
+    ptr = builder().CreateIntToPtr (i, type_void_ptr());
+    if (ptrtype)
+        ptr = ptr_cast (ptr, ptrtype);
+    return ptr;
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_alloca (llvm::Type *llvmtype, int n, const std::string &name)
+{
+    llvm::ConstantInt* numalloc = (llvm::ConstantInt*)constant(n);
+    return builder().CreateAlloca (llvmtype, numalloc, name);
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_alloca (const TypeDesc &type, int n, const std::string &name)
+{
+    return op_alloca (llvm_type(type.elementtype()), n*type.numelements(), name);
+}
+
+
+
+llvm::Value *
+LLVM_Util::call_function (llvm::Value *func, llvm::Value **args, int nargs)
+{
+    ASSERT (func);
+#if 0
+    llvm::outs() << "llvm_call_function " << *func << "\n";
+    llvm::outs() << nargs << " args:\n";
+    for (int i = 0;  i < nargs;  ++i)
+        llvm::outs() << "\t" << *(args[i]) << "\n";
+#endif
+    //llvm_gen_debug_printf (std::string("start ") + std::string(name));
+    llvm::Value *r = builder().CreateCall (func, llvm::ArrayRef<llvm::Value *>(args, nargs));
+    //llvm_gen_debug_printf (std::string(" end  ") + std::string(name));
+    return r;
+}
+
+
+
+llvm::Value *
+LLVM_Util::call_function (const char *name, llvm::Value **args, int nargs)
+{
+    llvm::Function *func = module()->getFunction (name);
+    if (! func)
+        std::cerr << "Couldn't find function " << name << "\n";
+    return call_function (func, args, nargs);
+}
+
+
+
+void
+LLVM_Util::mark_fast_func_call (llvm::Value *funccall)
+{
+    llvm::CallInst* call_inst = llvm::cast<llvm::CallInst>(funccall);
+    call_inst->setCallingConv (llvm::CallingConv::Fast);
+}
+
+
+
+void
+LLVM_Util::op_branch (llvm::BasicBlock *block)
+{
+    builder().CreateBr (block);
+    set_insert_point (block);
+}
+
+
+
+void
+LLVM_Util::op_branch (llvm::Value *cond, llvm::BasicBlock *trueblock,
+                      llvm::BasicBlock *falseblock)
+{
+    builder().CreateCondBr (cond, trueblock, falseblock);
+    set_insert_point (trueblock);
+}
+
+
+
+void
+LLVM_Util::set_insert_point (llvm::BasicBlock *block)
+{
+    builder().SetInsertPoint (block);
+}
+
+
+
+void
+LLVM_Util::op_return (llvm::Value *retval)
+{
+    if (retval)
+        builder().CreateRet (retval);
+    else
+        builder().CreateRetVoid ();
+}
+
+
+
+void
+LLVM_Util::op_memset (llvm::Value *ptr, int val, int len, int align)
+{
+    op_memset(ptr, val, constant(len), align);
+}
+
+
+
+void
+LLVM_Util::op_memset (llvm::Value *ptr, int val, llvm::Value *len, int align)
+{
+    // memset with i32 len
+    // and with an i8 pointer (dst) for LLVM-2.8
+    llvm::Type* types[] = {
+        (llvm::Type *) llvm::PointerType::get(llvm::Type::getInt8Ty(context()), 0),
+        (llvm::Type *) llvm::Type::getInt32Ty(context())
+    };
+
+    llvm::Function* func = llvm::Intrinsic::getDeclaration (module(),
+        llvm::Intrinsic::memset,
+        llvm::ArrayRef<llvm::Type *>(types, sizeof(types)/sizeof(llvm::Type*)));
+
+    // NOTE(boulos): constant(0) would return an i32
+    // version of 0, but we need the i8 version. If we make an
+    // ::constant(char val) though then we'll get ambiguity
+    // everywhere.
+    llvm::Value* fill_val = llvm::ConstantInt::get (context(),
+                                                    llvm::APInt(8, val));
+    // Non-volatile (allow optimizer to move it around as it wishes
+    // and even remove it if it can prove it's useless)
+    builder().CreateCall5 (func, ptr, fill_val, len, constant(align),
+                           constant_bool(false));
+}
+
+
+
+void
+LLVM_Util::op_memcpy (llvm::Value *dst, llvm::Value *src, int len, int align)
+{
+    // i32 len
+    // and with i8 pointers (dst and src) for LLVM-2.8
+    llvm::Type* types[] = {
+        (llvm::Type *) llvm::PointerType::get(llvm::Type::getInt8Ty(context()), 0),
+        (llvm::Type *) llvm::PointerType::get(llvm::Type::getInt8Ty(context()), 0),
+        (llvm::Type *) llvm::Type::getInt32Ty(context())
+    };
+
+    llvm::Function* func = llvm::Intrinsic::getDeclaration (module(),
+        llvm::Intrinsic::memcpy,
+        llvm::ArrayRef<llvm::Type *>(types, sizeof(types)/sizeof(llvm::Type*)));
+
+    // Non-volatile (allow optimizer to move it around as it wishes
+    // and even remove it if it can prove it's useless)
+    builder().CreateCall5 (func, dst, src,
+                           constant(len), constant(align), constant_bool(false));
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_load (llvm::Value *ptr)
+{
+    return builder().CreateLoad (ptr);
+}
+
+
+
+void
+LLVM_Util::op_store (llvm::Value *val, llvm::Value *ptr)
+{
+    builder().CreateStore (val, ptr);
+}
+
+
+
+llvm::Value *
+LLVM_Util::GEP (llvm::Value *ptr, llvm::Value *elem)
+{
+    return builder().CreateGEP (ptr, elem);
+}
+
+
+
+llvm::Value *
+LLVM_Util::GEP (llvm::Value *ptr, int elem)
+{
+    return builder().CreateConstGEP1_32 (ptr, elem);
+}
+
+
+
+llvm::Value *
+LLVM_Util::GEP (llvm::Value *ptr, int elem1, int elem2)
+{
+    return builder().CreateConstGEP2_32 (ptr, elem1, elem2);
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_add (llvm::Value *a, llvm::Value *b)
+{
+    if (a->getType() == type_float() && b->getType() == type_float())
+        return builder().CreateFAdd (a, b);
+    if (a->getType() == type_int() && b->getType() == type_int())
+        return builder().CreateAdd (a, b);
+    ASSERT (0 && "Op has bad value type combination");
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_sub (llvm::Value *a, llvm::Value *b)
+{
+    if (a->getType() == type_float() && b->getType() == type_float())
+        return builder().CreateFSub (a, b);
+    if (a->getType() == type_int() && b->getType() == type_int())
+        return builder().CreateSub (a, b);
+    ASSERT (0 && "Op has bad value type combination");
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_neg (llvm::Value *a)
+{
+    if (a->getType() == type_float())
+        return builder().CreateFNeg (a);
+    if (a->getType() == type_int())
+        return builder().CreateNeg (a);
+    ASSERT (0 && "Op has bad value type combination");
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_mul (llvm::Value *a, llvm::Value *b)
+{
+    if (a->getType() == type_float() && b->getType() == type_float())
+        return builder().CreateFMul (a, b);
+    if (a->getType() == type_int() && b->getType() == type_int())
+        return builder().CreateMul (a, b);
+    ASSERT (0 && "Op has bad value type combination");
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_div (llvm::Value *a, llvm::Value *b)
+{
+    if (a->getType() == type_float() && b->getType() == type_float())
+        return builder().CreateFDiv (a, b);
+    if (a->getType() == type_int() && b->getType() == type_int())
+        return builder().CreateSDiv (a, b);
+    ASSERT (0 && "Op has bad value type combination");
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_mod (llvm::Value *a, llvm::Value *b)
+{
+    if (a->getType() == type_float() && b->getType() == type_float())
+        return builder().CreateFRem (a, b);
+    if (a->getType() == type_int() && b->getType() == type_int())
+        return builder().CreateSRem (a, b);
+    ASSERT (0 && "Op has bad value type combination");
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_float_to_int (llvm::Value* a)
+{
+    if (a->getType() == type_float())
+        return builder().CreateFPToSI(a, type_int());
+    if (a->getType() == type_int())
+        return a;
+    ASSERT (0 && "Op has bad value type combination");
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_float_to_double (llvm::Value* a)
+{
+    ASSERT (a->getType() == type_float());
+    return builder().CreateFPExt(a, llvm::Type::getDoubleTy(context()));
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_int_to_float (llvm::Value* a)
+{
+    if (a->getType() == type_int())
+        return builder().CreateSIToFP(a, type_float());
+    if (a->getType() == type_float())
+        return a;
+    ASSERT (0 && "Op has bad value type combination");
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_bool_to_int (llvm::Value* a)
+{
+    if (a->getType() == type_bool())
+        return builder().CreateZExt (a, type_int());
+    if (a->getType() == type_int())
+        return a;
+    ASSERT (0 && "Op has bad value type combination");
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_and (llvm::Value *a, llvm::Value *b)
+{
+    return builder().CreateAnd (a, b);
+}
+
+
+llvm::Value *
+LLVM_Util::op_or (llvm::Value *a, llvm::Value *b)
+{
+    return builder().CreateOr (a, b);
+}
+
+
+llvm::Value *
+LLVM_Util::op_xor (llvm::Value *a, llvm::Value *b)
+{
+    return builder().CreateXor (a, b);
+}
+
+
+llvm::Value *
+LLVM_Util::op_shl (llvm::Value *a, llvm::Value *b)
+{
+    return builder().CreateShl (a, b);
+}
+
+
+llvm::Value *
+LLVM_Util::op_shr (llvm::Value *a, llvm::Value *b)
+{
+    if (a->getType() == type_int() && b->getType() == type_int())
+        return builder().CreateAShr (a, b);  // signed int -> arithmetic shift
+    ASSERT (0 && "Op has bad value type combination");
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_not (llvm::Value *a)
+{
+    return builder().CreateNot (a);
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_select (llvm::Value *cond, llvm::Value *a, llvm::Value *b)
+{
+    return builder().CreateSelect (cond, a, b);
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_eq (llvm::Value *a, llvm::Value *b, bool ordered)
+{
+    ASSERT (a->getType() == b->getType());
+    if (a->getType() == type_float())
+        return ordered ? builder().CreateFCmpOEQ (a, b) : builder().CreateFCmpUEQ (a, b);
+    else
+        return builder().CreateICmpEQ (a, b);
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_ne (llvm::Value *a, llvm::Value *b, bool ordered)
+{
+    ASSERT (a->getType() == b->getType());
+    if (a->getType() == type_float())
+        return ordered ? builder().CreateFCmpONE (a, b) : builder().CreateFCmpUNE (a, b);
+    else
+        return builder().CreateICmpNE (a, b);
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_gt (llvm::Value *a, llvm::Value *b, bool ordered)
+{
+    ASSERT (a->getType() == b->getType());
+    if (a->getType() == type_float())
+        return ordered ? builder().CreateFCmpOGT (a, b) : builder().CreateFCmpUGT (a, b);
+    else
+        return builder().CreateICmpSGT (a, b);
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_lt (llvm::Value *a, llvm::Value *b, bool ordered)
+{
+    ASSERT (a->getType() == b->getType());
+    if (a->getType() == type_float())
+        return ordered ? builder().CreateFCmpOLT (a, b) : builder().CreateFCmpULT (a, b);
+    else
+        return builder().CreateICmpSLT (a, b);
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_ge (llvm::Value *a, llvm::Value *b, bool ordered)
+{
+    ASSERT (a->getType() == b->getType());
+    if (a->getType() == type_float())
+        return ordered ? builder().CreateFCmpOGE (a, b) : builder().CreateFCmpUGE (a, b);
+    else
+        return builder().CreateICmpSGE (a, b);
+}
+
+
+
+llvm::Value *
+LLVM_Util::op_le (llvm::Value *a, llvm::Value *b, bool ordered)
+{
+    ASSERT (a->getType() == b->getType());
+    if (a->getType() == type_float())
+        return ordered ? builder().CreateFCmpOLE (a, b) : builder().CreateFCmpULE (a, b);
+    else
+        return builder().CreateICmpSLE (a, b);
+}
+
+
+
+void
+LLVM_Util::write_bitcode_file (const char *filename, std::string *err)
+{
+#if OSL_LLVM_VERSION >= 36
+    std::error_code local_error;
+    llvm::raw_fd_ostream out (filename, local_error, llvm::sys::fs::F_None);
+#elif OSL_LLVM_VERSION >= 35
+    std::string local_error;
+    llvm::raw_fd_ostream out (filename, err ? *err : local_error, llvm::sys::fs::F_None);
+#else
+    std::string local_error;
+    llvm::raw_fd_ostream out (filename, err ? *err : local_error);
+#endif
+    llvm::WriteBitcodeToFile (module(), out);
+
+#if OSL_LLVM_VERSION >= 36
+    if (err && local_error)
+        *err = local_error.message ();
+#endif
+}
+
+
+
+std::string
+LLVM_Util::bitcode_string (llvm::Function *func)
+{
+    std::string s;
+    llvm::raw_string_ostream stream (s);
+    stream << (*func);
+    return stream.str();
+}
+
+
+
+void
+LLVM_Util::delete_func_body (llvm::Function *func)
+{
+    func->deleteBody ();
+}
+
+
+
+bool
+LLVM_Util::func_is_empty (llvm::Function *func)
+{
+    return func->size() == 1 // func has just one basic block
+        && func->front().size() == 1;  // the block has one instruction,
+                                       ///   presumably the ret
+}
+
+
+std::string
+LLVM_Util::func_name (llvm::Function *func)
+{
+    return func->getName().str();
+}
+
+
+}; // namespace pvt
+OSL_NAMESPACE_EXIT
diff -purN a/src/liboslexec/llvmutil_test.cpp b/src/liboslexec/llvmutil_test.cpp
--- a/src/liboslexec/llvmutil_test.cpp	2016-06-27 22:34:50.000000000 +0100
+++ b/src/liboslexec/llvmutil_test.cpp	2016-06-27 22:37:25.000000000 +0100
@@ -33,7 +33,9 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 #include <OpenImageIO/argparse.h>
 #include <OpenImageIO/strutil.h>
 #include <OpenImageIO/sysutil.h>
+
 #include "OSL/llvm_util.h"
+#include <llvm/ExecutionEngine/RTDyldMemoryManager.h>
 
 
 typedef int (*IntFuncOfTwoInts)(int,int);
@@ -41,6 +43,8 @@ typedef int (*IntFuncOfTwoInts)(int,int)
 static bool verbose = false;
 static bool debug = false;
 static int memtest = 0;
+static int opt = -1;
+static bool orc = false;
 
 
 
@@ -56,6 +60,8 @@ getargs (int argc, char *argv[])
                 "-v", &verbose, "Verbose mode",
                 "--debug", &debug, "Debug mode",
                 "--memtest %d", &memtest, "Memory test mode (arg: iterations)",
+                "--opt %d", &opt, "Opt level (0=basic, 1-3=like clang)",
+                "--orc", &orc, "Use ORC JIT",
                 // "--iters %d", &iterations,
                 //     Strutil::format("Number of iterations (default: %d)", iterations).c_str(),
                 // "--trials %d", &ntrials, "Number of trials",
@@ -77,23 +83,25 @@ getargs (int argc, char *argv[])
 // function on the fly, JIT it, and call it:
 //      int myadd (int arg1, int arg2)
 //      {
-//          return arg1 + arg2;    
+//          return arg1 + arg2;
 //      }
 //
 void
 test_int_func ()
 {
     // Setup
-    OSL::pvt::LLVM_Util ll;
+    OSL::LLVM_Util ll;
+    ll.orc_jit (orc);
 
     // Make a function with prototype:   int myadd (int arg1, int arg2)
-    // and make it the current function.
-    llvm::Function *func = ll.make_function ("myadd",         // name
+    // and make it the current function. A module will automatically be
+    // created to hold the function.
+    const char funcname[] = "myadd";
+    llvm::Function *func = ll.make_function (funcname,         // name
                                              false,           // fastcall
                                              ll.type_int(),   // return
                                              ll.type_int(),   // arg1
                                              ll.type_int());  // arg2
-    ll.current_function (func);
 
     // Generate the ops for this function:  return arg1 + arg2
     llvm::Value *arg1 = ll.current_function_arg (0);
@@ -101,16 +109,20 @@ test_int_func ()
     llvm::Value *sum = ll.op_add (arg1, arg2);
     ll.op_return (sum);
 
-    // Optimize it
-    ll.setup_optimization_passes (0);
-    ll.do_optimize ();
-
+    // Optimize it and compile
+    if (opt >= 0) {
+        ll.setup_optimization_passes (opt);
+        ll.do_optimize ();
+    }
     // Print the optimized bitcode
     std::cout << "Generated the following bitcode:\n"
               << ll.bitcode_string(func) << "\n";
 
+    ll.module_done ();
+
+
     // Ask for a callable function (will JIT on demand)
-    IntFuncOfTwoInts myadd = (IntFuncOfTwoInts) ll.getPointerToFunction (func);
+    IntFuncOfTwoInts myadd = (IntFuncOfTwoInts) ll.get_compiled_function (funcname);
 
     // Call it:
     int result = myadd (13, 29);
@@ -120,59 +132,80 @@ test_int_func ()
 
 
 
+
+extern "C" {
+// __attribute__ ((visibility ("default")))
+float sqr (float x) { return x*x; }
+}
+
+
+
 // This demonstrates the use of LLVM_Util to generate the following
 // function on the fly, JIT it, and call it:
-//      void myaddv (Vec3 *result, Vec3 *a, float b)
+//      void myfunc (Vec3 *result, Vec3 *a, float b)
 //      {
-//          *result = (*a) * b;
+//          *result = (*a) * sqr(b);
 //      }
 //
 void
 test_triple_func ()
 {
     // Setup
-    OSL::pvt::LLVM_Util ll;
+    OSL::LLVM_Util ll;
+    ll.orc_jit (orc);
+
+    // Declare stub for sqr
+    llvm::Type* sqr_args[] = { ll.type_float() };
+    ll.declare_extern_function ("sqr", ll.type_float(), sqr_args);
 
     // Make a function with prototype:   int myadd (int arg1, int arg2)
-    // and make it the current function.
-    llvm::Function *func = ll.make_function ("myaddv",        // name
+    // and make it the current function. A module will automatically be
+    // created to hold the function.
+    const char funcname[] = "myfunc";
+    llvm::Function *func = ll.make_function (funcname,        // name
                                              false,           // fastcall
                                              ll.type_void(),  // return
                                              (llvm::Type *)ll.type_triple_ptr(), // result
                                              (llvm::Type *)ll.type_triple_ptr(), // arg1
                                              ll.type_float());  // arg2
-    ll.current_function (func);
 
     // Generate the ops for this function:  r = a*b
     llvm::Value *rptr = ll.current_function_arg (0);
     llvm::Value *aptr = ll.current_function_arg (1);
     llvm::Value *b = ll.current_function_arg (2);
+    llvm::Value *bsq = ll.call_function ("sqr", b);
     for (int i = 0; i < 3; ++i) {
         llvm::Value *r_elptr = ll.GEP (rptr, 0, i);
         llvm::Value *a_elptr = ll.GEP (aptr, 0, i);
-        llvm::Value *product = ll.op_mul (ll.op_load(a_elptr), b);
+        llvm::Value *product = ll.op_mul (ll.op_load(a_elptr), bsq);
         ll.op_store (product, r_elptr);
     }
     ll.op_return ();
 
-    // Optimize it
-    ll.setup_optimization_passes (0);
-    ll.do_optimize ();
+    // Optimize it and compile
+    if (opt >= 0) {
+        ll.setup_optimization_passes (opt);
+        ll.do_optimize ();
+    }
+
+    // ll.write_bitcode_file ("out.bc");
 
     // Print the optimized bitcode
     std::cout << "Generated the following bitcode:\n"
               << ll.bitcode_string(func) << "\n";
 
+    ll.module_done ();
+
     // Ask for a callable function (will JIT on demand)
     typedef void (*FuncVecVecFloat)(void*, void*, float);
-    FuncVecVecFloat f = (FuncVecVecFloat) ll.getPointerToFunction (func);
+    FuncVecVecFloat f = (FuncVecVecFloat) ll.get_compiled_function (funcname);
 
     // Call it:
     {
     float r[3], a[3] = { 1.0, 2.0, 3.0 }, b = 42.0;
     f (r, a, b);
     std::cout << "The result is " << r[0] << ' ' << r[1] << ' ' << r[2] << "\n";
-    ASSERT (r[0] == 42.0 && r[1] == 84.0 && r[2] == 126.0);
+    ASSERT (r[0] == 1764.0 && r[1] == 3528.0 && r[2] == 5292.0);
     }
 }
 
@@ -183,20 +216,19 @@ test_triple_func ()
 //      int mybig (int arg1, int arg2);
 //
 IntFuncOfTwoInts
-test_big_func (bool do_print=false)
+test_big_func (OSL::LLVM_Util &ll, bool do_print=false)
 {
-    // Setup
-    OSL::pvt::LLVM_Util ll;
+    // Start a new module
+    ll.new_module ();
 
     // Make a function with prototype:  int myadd (int arg1, int arg2)
     // and make it the current function in the current module.
-    llvm::Function *func = ll.make_function ("myadd",         // name
+    const char funcname[] = "myadd";
+    llvm::Function *func = ll.make_function (funcname,        // name
                                              false,           // fastcall
                                              ll.type_int(),   // return
                                              ll.type_int(),   // arg1
                                              ll.type_int());  // arg2
-    // Make it the current function and get it ready to accept IR.
-    ll.current_function (func);
 
     // Generate the ops for this function:  return arg1 + arg2
     llvm::Value *arg1 = ll.current_function_arg (0);
@@ -209,19 +241,22 @@ test_big_func (bool do_print=false)
     ll.op_return (sum);
 
     // Print the optimized bitcode
-    // if (do_print)
-    //     std::cout << "Generated the following bitcode:\n"
-    //               << ll.bitcode_string(func) << "\n";
-
-    ll.setup_optimization_passes (0);
-    ll.do_optimize ();
-
     if (do_print)
-        std::cout << "After optimizing:\n"
+        std::cout << "Generated the following bitcode:\n"
                   << ll.bitcode_string(func) << "\n";
 
+    if (opt >= 0) {
+        ll.setup_optimization_passes (opt);
+        ll.do_optimize ();
+        if (do_print)
+            std::cout << "After optimizing:\n"
+                      << ll.bitcode_string(func) << "\n";
+    }
+
+    ll.module_done ();
+
     // Ask for a callable function (will JIT on demand)
-    IntFuncOfTwoInts myadd = (IntFuncOfTwoInts) ll.getPointerToFunction (func);
+    IntFuncOfTwoInts myadd = (IntFuncOfTwoInts) ll.get_compiled_function (funcname);
 
     // We're done with the module now
     // ll.remove_module (module);
@@ -244,8 +279,10 @@ main (int argc, char *argv[])
     test_triple_func();
 
     if (memtest) {
+        OSL::LLVM_Util ll;
+        ll.orc_jit (orc);
         for (int i = 0; i < memtest; ++i) {
-            IntFuncOfTwoInts f = test_big_func (i==0);
+            IntFuncOfTwoInts f = test_big_func (ll, i==0);
             int r = f (42, 42);
             ASSERT (r == 84);
         }
diff -purN a/src/liboslexec/oslexec_pvt.h b/src/liboslexec/oslexec_pvt.h
--- a/src/liboslexec/oslexec_pvt.h	2016-06-27 22:34:50.000000000 +0100
+++ b/src/liboslexec/oslexec_pvt.h	2016-06-27 22:37:25.000000000 +0100
@@ -69,6 +69,8 @@ namespace Strutil = OIIO::Strutil;
 
 OSL_NAMESPACE_ENTER
 
+class LLVM_Util;   // forward declaration of the name
+
 
 
 struct PerThreadInfo
@@ -682,10 +684,6 @@ private:
         return p;
     }
 
-    /// Set up LLVM -- make sure we have a Context, Module, ExecutionEngine,
-    /// retained JITMemoryManager, etc.
-    void SetupLLVM ();
-
     void setup_op_descriptors ();
 
     RendererServices *m_renderer;         ///< Renderer services
@@ -743,6 +741,7 @@ private:
     bool m_optimize_nondebug;             ///< Fully optimize non-debug!
     int m_opt_passes;                     ///< Opt passes per layer
     int m_llvm_optimize;                  ///< OSL optimization strategy
+    bool m_llvm_orcjit;                   ///< Use ORC JIT
     int m_debug;                          ///< Debugging output
     int m_llvm_debug;                     ///< More LLVM debugging output
     int m_llvm_debug_layers;              ///< Add layer enter/exit printfs
@@ -780,6 +779,10 @@ private:
     mutable mutex m_mutex;                ///< Thread safety
     mutable boost::thread_specific_ptr<PerThreadInfo> m_perthread_info;
 
+    // LLVM stuff
+    std::unique_ptr<LLVM_Util> m_llvmutil;
+    mutex m_llvmutil_mutex;
+
     // Stats
     atomic_int m_stat_shaders_loaded;     ///< Stat: shaders loaded
     atomic_int m_stat_shaders_requested;  ///< Stat: shaders requested
diff -purN a/src/liboslexec/shadingsys.cpp b/src/liboslexec/shadingsys.cpp
--- a/src/liboslexec/shadingsys.cpp	2016-06-27 22:34:50.000000000 +0100
+++ b/src/liboslexec/shadingsys.cpp	2016-06-27 22:37:25.000000000 +0100
@@ -634,7 +634,7 @@ ShadingSystemImpl::ShadingSystemImpl (Re
       m_opt_seed_bblock_aliases(true),
       m_optimize_nondebug(false),
       m_opt_passes(10),
-      m_llvm_optimize(0),
+      m_llvm_optimize(0), m_llvm_orcjit(false),
       m_debug(0), m_llvm_debug(0), m_llvm_debug_layers(0),
       m_commonspace_synonym("world"),
       m_colorspace("Rec709"),
@@ -1046,6 +1046,7 @@ ShadingSystemImpl::attribute (string_vie
     ATTR_SET ("opt_passes", int, m_opt_passes);
     ATTR_SET ("optimize_nondebug", int, m_optimize_nondebug);
     ATTR_SET ("llvm_optimize", int, m_llvm_optimize);
+    ATTR_SET ("llvm_orcjit", int, m_llvm_orcjit);
     ATTR_SET ("llvm_debug", int, m_llvm_debug);
     ATTR_SET ("llvm_debug_layers", int, m_llvm_debug_layers);
     ATTR_SET ("strict_messages", int, m_strict_messages);
@@ -1151,6 +1152,7 @@ ShadingSystemImpl::getattribute (string_
     ATTR_DECODE ("opt_passes", int, m_opt_passes);
     ATTR_DECODE ("optimize_nondebug", int, m_optimize_nondebug);
     ATTR_DECODE ("llvm_optimize", int, m_llvm_optimize);
+    ATTR_DECODE ("llvm_orcjit", int, m_llvm_orcjit);
     ATTR_DECODE ("debug", int, m_debug);
     ATTR_DECODE ("llvm_debug", int, m_llvm_debug);
     ATTR_DECODE ("llvm_debug_layers", int, m_llvm_debug_layers);
@@ -1542,6 +1544,7 @@ ShadingSystemImpl::getstats (int level)
 #define STROPT(name) if (m_##name.size()) opt += Strutil::format(#name "=\"%s\" ", m_##name)
     INTOPT (optimize);
     INTOPT (llvm_optimize);
+    INTOPT (llvm_orcjit);
     INTOPT (debug);
     INTOPT (profile);
     INTOPT (llvm_debug);
@@ -2605,8 +2608,24 @@ ShadingSystemImpl::optimize_group (Shade
         group.m_attribute_scopes.push_back (f.scope);
     }
 
-    BackendLLVM lljitter (*this, group, ctx);
-    lljitter.run ();
+    {
+        // FIXME -- for now, have only one LLVM_Util for the whole
+        // ShadingSystem, guard it with a mutex. Later, we should make a
+        // pool of them so multiple threads can JIT simultaneously.
+        lock_guard lock (m_llvmutil_mutex);
+        if (! m_llvmutil)
+            m_llvmutil.reset (new LLVM_Util);
+        BackendLLVM lljitter (*this, group, ctx, *m_llvmutil);
+        lljitter.run ();
+
+        m_stat_total_llvm_time += lljitter.m_stat_total_llvm_time;
+        m_stat_llvm_setup_time += lljitter.m_stat_llvm_setup_time;
+        m_stat_llvm_irgen_time += lljitter.m_stat_llvm_irgen_time;
+        m_stat_llvm_opt_time += lljitter.m_stat_llvm_opt_time;
+        m_stat_llvm_jit_time += lljitter.m_stat_llvm_jit_time;
+        m_stat_max_llvm_local_mem = std::max (m_stat_max_llvm_local_mem,
+                                              lljitter.m_llvm_local_mem);
+    }
 
     group_post_jit_cleanup (group);
 
@@ -2617,13 +2636,6 @@ ShadingSystemImpl::optimize_group (Shade
     m_stat_optimization_time += timer();
     m_stat_opt_locking_time += locking_time + rop.m_stat_opt_locking_time;
     m_stat_specialization_time += rop.m_stat_specialization_time;
-    m_stat_total_llvm_time += lljitter.m_stat_total_llvm_time;
-    m_stat_llvm_setup_time += lljitter.m_stat_llvm_setup_time;
-    m_stat_llvm_irgen_time += lljitter.m_stat_llvm_irgen_time;
-    m_stat_llvm_opt_time += lljitter.m_stat_llvm_opt_time;
-    m_stat_llvm_jit_time += lljitter.m_stat_llvm_jit_time;
-    m_stat_max_llvm_local_mem = std::max (m_stat_max_llvm_local_mem,
-                                          lljitter.m_llvm_local_mem);
     m_stat_groups_compiled += 1;
     m_stat_instances_compiled += group.nlayers();
     m_groups_to_compile_count -= 1;
diff -purN a/.travis.yml b/.travis.yml
--- a/.travis.yml	2016-06-27 22:34:50.000000000 +0100
+++ b/.travis.yml	2016-06-27 22:37:25.000000000 +0100
@@ -31,8 +31,8 @@ addons:
       - g++-6
       - libboost1.55-all-dev
       - libtiff4-dev
-      - llvm-3.4-dev
-      - clang-3.4
+      - llvm3.8
+      - clang-3.8
 
 cache:
     ccache: true
@@ -59,7 +59,7 @@ install:
     - export CCACHE_CPP2=1
     - if [ $TRAVIS_OS_NAME == osx ] ; then
           src/build-scripts/install_homebrew_deps.bash ;
-          export LLVM_DIRECTORY=/usr/local/Cellar/llvm34/3.4.2/lib/llvm-3.4 ;
+          export LLVM_DIRECTORY=/usr/local/opt/llvm38/lib/llvm-3.8 ;
       elif [ $TRAVIS_OS_NAME == linux ] ; then
           CXX="ccache $CXX" CCACHE_CPP2=1 src/build-scripts/build_openexr.bash ;
           export ILMBASE_HOME=$PWD/openexr-install ;
@@ -109,14 +109,6 @@ matrix:
       - os: linux
         compiler: clang
     include:
-    # Make sure we can still build C++03, both platforms
-      - os: linux
-        dist: trusty
-        compiler: gcc
-        env: USE_CPP11=0
-      - os: osx
-        compiler: clang
-        env: USE_CPP11=0
     # Test against the older release branch of OIIO (all the other tests
     # are against OIIO master)
       - os: linux
